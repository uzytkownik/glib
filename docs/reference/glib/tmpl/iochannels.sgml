<!-- ##### SECTION Title ##### -->
IO Channels

<!-- ##### SECTION Short_Description ##### -->
portable support for using files, pipes and sockets.

<!-- ##### SECTION Long_Description ##### -->
<para>
The #GIOChannel data type aims to provide a portable method for using file
descriptors, pipes, and sockets, and integrating them into the
<link linkend="glib-The-Main-Event-Loop">main event loop</link>.
Currently full support is available on Unix platforms, though support for
Windows is only partially complete.
</para>
<para>
To create a new #GIOChannel on Unix systems use g_io_channel_unix_new().
This works for plain file descriptors, pipes and sockets.
Alternately, a channel can be created for a file in a system independent
manner using g_io_channel_new_file().
</para>
<para>
Once a #GIOChannel has been created, it can be used in a generic manner
with the functions g_io_channel_read_chars(), g_io_channel_write_chars(),
g_io_channel_seek_position(), and g_io_channel_close().
</para>
<para>
To add a #GIOChannel to the 
<link linkend="glib-The-Main-Event-Loop">main event loop</link>
use g_io_add_watch() or g_io_add_watch_full(). Here you specify which events
you are interested in on the #GIOChannel, and provide a function to be
called whenever these events occur.
</para>
<para>
#GIOChannel instances are created with an initial reference count of 1.
g_io_channel_ref() and g_io_channel_unref() can be used to increment or
decrement the reference count respectively. When the reference count falls
to 0, the #GIOChannel is freed. (Though it isn't closed automatically,
unless it was created using g_io_channel_new_from_file().)
Using g_io_add_watch() or g_io_add_watch_full() increments a channel's
reference count.
</para>
<para>
GTK+ contains the convenience function gtk_input_add_full()
which creates a #GIOChannel from a file descriptor and adds it to the
<link linkend="glib-The-Main-Event-Loop">main event loop</link>.
The event source can later be removed with gtk_input_remove().
Similar functions can also be found in GDK.
</para>
<para>
The new functions g_io_channel_read_chars(), g_io_channel_read_line(),
g_io_channel_read_line_string(), g_io_channel_read_to_end(),
g_io_channel_write_chars(), g_io_channel_seek_position(),
and g_io_channel_flush() should not be mixed with the
depricated functions g_io_channel_read(), g_io_channel_write(),
and g_io_channel_seek() on the same channel.
</para>

<!-- ##### SECTION See_Also ##### -->
<para>
<variablelist>

<varlistentry>
<term>gtk_input_add_full(), gtk_input_remove(), gdk_input_add(),
gdk_input_add_full(), gdk_input_remove()</term>
<listitem><para>
Convenience functions for creating #GIOChannel instances and adding them to the
<link linkend="glib-The-Main-Event-Loop">main event loop</link>.
</para></listitem>
</varlistentry>

</variablelist>
</para>

<!-- ##### STRUCT GIOChannel ##### -->
<para>
A data structure representing an IO Channel. The fields should be considered
private and should only be accessed with the following functions.
</para>


<!-- ##### FUNCTION g_io_channel_unix_new ##### -->
<para>
Creates a new #GIOChannel given a file descriptor.
On Unix systems this works for plain files, pipes, and sockets.
</para>
<para>
The returned #GIOChannel has a reference count of 1.
</para>

@fd: a file descriptor.
@Returns: a new #GIOChannel.


<!-- ##### FUNCTION g_io_channel_unix_get_fd ##### -->
<para>
Returns the file descriptor of the Unix #GIOChannel.
</para>

@channel: a #GIOChannel, created with g_io_channel_unix_new().
@Returns: the file descriptor of the #GIOChannel.


<!-- ##### FUNCTION g_io_channel_init ##### -->
<para>
Initializes a #GIOChannel struct. This is called by each of the above functions
when creating a #GIOChannel, and so is not often needed by the application
programmer (unless you are creating a new type of #GIOChannel).
</para>

@channel: a #GIOChannel.


<!-- ##### FUNCTION g_io_channel_new_file ##### -->
<para>
</para>

@filename: 
@mode: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_read_chars ##### -->
<para>

</para>

@channel: 
@buf: 
@count: 
@bytes_read: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_read_unichar ##### -->
<para>

</para>

@channel: 
@thechar: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_read_line ##### -->
<para>

</para>

@channel: 
@str_return: 
@length: 
@terminator_pos: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_read_line_string ##### -->
<para>

</para>

@channel: 
@buffer: 
@terminator_pos: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_read_to_end ##### -->
<para>

</para>

@channel: 
@str_return: 
@length: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_write_chars ##### -->
<para>

</para>

@channel: 
@buf: 
@count: 
@bytes_written: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_write_unichar ##### -->
<para>

</para>

@channel: 
@thechar: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_flush ##### -->
<para>

</para>

@channel: 
@error: 
@Returns: 
<!-- # Unused Parameters # -->
@err: 


<!-- ##### FUNCTION g_io_channel_seek_position ##### -->
<para>

</para>

@channel: 
@offset: 
@type: 
@error: 
@Returns: 
<!-- # Unused Parameters # -->
@err: 


<!-- ##### ENUM GSeekType ##### -->
<para>
An enumeration specifying the base position for a g_io_channel_seek_position()
operation.

<informaltable pgwide=1 frame="none" role="enum">
<tgroup cols="2"><colspec colwidth="2*"><colspec colwidth="8*">
<tbody>

<row>
<entry>G_SEEK_CUR</entry>
<entry>the current position in the file.</entry>
</row>

<row>
<entry>G_SEEK_SET</entry>
<entry>the start of the file.</entry>
</row>

<row>
<entry>G_SEEK_END</entry>
<entry>the end of the file.</entry>
</row>

</tbody></tgroup></informaltable>

</para>

@G_SEEK_CUR: 
@G_SEEK_SET: 
@G_SEEK_END: 

<!-- ##### FUNCTION g_io_channel_shutdown ##### -->
<para>

</para>

@channel: 
@flush: 
@err: 
@Returns: 


<!-- ##### ENUM GIOStatus ##### -->
<para>

</para>

@G_IO_STATUS_ERROR: 
@G_IO_STATUS_NORMAL: 
@G_IO_STATUS_EOF: 
@G_IO_STATUS_AGAIN: 

<!-- ##### ENUM GIOChannelError ##### -->
<para>

</para>

@G_IO_CHANNEL_ERROR_FBIG: 
@G_IO_CHANNEL_ERROR_INVAL: 
@G_IO_CHANNEL_ERROR_IO: 
@G_IO_CHANNEL_ERROR_ISDIR: 
@G_IO_CHANNEL_ERROR_NOSPC: 
@G_IO_CHANNEL_ERROR_NXIO: 
@G_IO_CHANNEL_ERROR_OVERFLOW: 
@G_IO_CHANNEL_ERROR_PIPE: 
@G_IO_CHANNEL_ERROR_FAILED: 

<!-- ##### MACRO G_IO_CHANNEL_ERROR ##### -->
<para>

</para>



<!-- ##### FUNCTION g_io_channel_error_quark ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION g_io_channel_error_from_errno ##### -->
<para>

</para>

@en: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_ref ##### -->
<para>
Increments the reference count of a #GIOChannel.
</para>

@channel: a #GIOChannel.


<!-- ##### FUNCTION g_io_channel_unref ##### -->
<para>
Decrements the reference count of a #GIOChannel.
</para>

@channel: a #GIOChannel.


<!-- ##### FUNCTION g_io_create_watch ##### -->
<para>
Creates a #GSource that's dispatched when @condition is met for the given
@channel. For example, if condition is #G_IO_IN, the source will be dispatched
when there's data available for reading.  g_io_add_watch() is a simpler
interface to this same functionality, for the case where you want to add the
source to the default main loop at the default priority.
</para>

@channel: a #GIOChannel to watch
@condition: conditions to watch for
@Returns: a new #GSource


<!-- ##### FUNCTION g_io_add_watch ##### -->
<para>
Adds the #GIOChannel into the
<link linkend="glib-The-Main-Event-Loop">main event loop</link>
with the default priority.
</para>

@channel: a #GIOChannel.
@condition: the condition to watch for.
@func: the function to call when the condition is satisfied.
@user_data: user data to pass to @func.
@Returns: the event source id.


<!-- ##### FUNCTION g_io_add_watch_full ##### -->
<para>
Adds the #GIOChannel into the
<link linkend="glib-The-Main-Event-Loop">main event loop</link>
with the given priority.
</para>

@channel: a #GIOChannel.
@priority: the priority of the #GIOChannel source.
@condition: the condition to watch for.
@func: the function to call when the condition is satisfied.
@user_data: user data to pass to @func.
@notify: the function to call when the source is removed.
@Returns: the event source id.


<!-- ##### ENUM GIOCondition ##### -->
<para>
A bitwise combination representing a condition to watch for on an event
source.

<informaltable pgwide=1 frame="none" role="enum">
<tgroup cols="2"><colspec colwidth="2*"><colspec colwidth="8*">
<tbody>

<row>
<entry>G_IO_IN</entry>
<entry>There is data to read.</entry>
</row>

<row>
<entry>G_IO_OUT</entry>
<entry>Data can be written (without blocking).</entry>
</row>

<row>
<entry>G_IO_PRI</entry>
<entry>There is urgent data to read.</entry>
</row>

<row>
<entry>G_IO_ERR</entry>
<entry>Error condition.</entry>
</row>

<row>
<entry>G_IO_HUP</entry>
<entry>Hung up (the connection has been broken, usually for pipes and
sockets).</entry>
</row>

<row>
<entry>G_IO_NVAL</entry>
<entry>Invalid request. The file descriptor is not open.</entry>
</row>

</tbody></tgroup></informaltable>

</para>

@G_IO_IN: 
@G_IO_OUT: 
@G_IO_PRI: 
@G_IO_ERR: 
@G_IO_HUP: 
@G_IO_NVAL: 

<!-- ##### USER_FUNCTION GIOFunc ##### -->
<para>
Specifies the type of function passed to g_io_add_watch() or
g_io_add_watch_full(), which is called when the requested condition on a
#GIOChannel is satisfied.
</para>

@source: the #GIOChannel event source.
@condition: the condition which has been satisfied.
@data: user data set in g_io_add_watch() or g_io_add_watch_full().
@Returns: the function should return FALSE if the event source should be
removed.


<!-- ##### STRUCT GIOFuncs ##### -->
<para>
A table of functions used to handle different types of #GIOChannel in a
generic way.
</para>

@io_read: 
@io_write: 
@io_seek: 
@io_close: 
@io_create_watch: 
@io_free: 
@io_set_flags: 
@io_get_flags: 

<!-- ##### FUNCTION g_io_channel_get_buffer_size ##### -->
<para>

</para>

@channel: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_set_buffer_size ##### -->
<para>

</para>

@channel: 
@size: 


<!-- ##### FUNCTION g_io_channel_get_buffer_condition ##### -->
<para>

</para>

@channel: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_get_flags ##### -->
<para>

</para>

@channel: 
@Returns: 
<!-- # Unused Parameters # -->
@flags: 
@error: 


<!-- ##### FUNCTION g_io_channel_set_flags ##### -->
<para>

</para>

@channel: 
@flags: 
@error: 
@Returns: 


<!-- ##### ENUM GIOFlags ##### -->
<para>

</para>

@G_IO_FLAG_APPEND: 
@G_IO_FLAG_NONBLOCK: 
@G_IO_FLAG_IS_READABLE: 
@G_IO_FLAG_IS_WRITEABLE: 
@G_IO_FLAG_IS_SEEKABLE: 
@G_IO_FLAG_MASK: 
@G_IO_FLAG_GET_MASK: 
@G_IO_FLAG_SET_MASK: 

<!-- ##### FUNCTION g_io_channel_get_line_term ##### -->
<para>

</para>

@channel: 
@length: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_set_line_term ##### -->
<para>

</para>

@channel: 
@line_term: 
@length: 


<!-- ##### FUNCTION g_io_channel_get_buffered ##### -->
<para>

</para>

@channel: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_set_buffered ##### -->
<para>

</para>

@channel: 
@buffered: 


<!-- ##### FUNCTION g_io_channel_get_encoding ##### -->
<para>

</para>

@channel: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_set_encoding ##### -->
<para>

</para>

@channel: 
@encoding: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_get_close_on_unref ##### -->
<para>

</para>

@channel: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_set_close_on_unref ##### -->
<para>

</para>

@channel: 
@do_close: 


<!-- ##### FUNCTION g_io_channel_read ##### -->
<para>
</para>

@channel: 
@buf: 
@count: 
@bytes_read: 
@Returns: 


<!-- ##### ENUM GIOError ##### -->
<para>
#GIOError is only used by the depricated functions g_io_channel_read(),
g_io_channel_write(), and g_io_channel_seek().
</para>

@G_IO_ERROR_NONE: 
@G_IO_ERROR_AGAIN: 
@G_IO_ERROR_INVAL: 
@G_IO_ERROR_UNKNOWN: 

<!-- ##### FUNCTION g_io_channel_write ##### -->
<para>
</para>

@channel: 
@buf: 
@count: 
@bytes_written: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_seek ##### -->
<para>
</para>

@channel: 
@offset: 
@type.
@type: 
@Returns: 


<!-- ##### FUNCTION g_io_channel_close ##### -->
<para>
</para>

@channel: 


