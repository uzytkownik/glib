<STRUCT>
<NAME>GError</NAME>
</STRUCT>
<STRUCT>
<NAME>GError</NAME>
struct GError
{
  GQuark       domain;
  gint         code;
  gchar       *message;
};
</STRUCT>
<FUNCTION>
<NAME>g_error_new</NAME>
<RETURNS>GError *</RETURNS>
GQuark         domain,gint           code,const gchar   *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_error_new_literal</NAME>
<RETURNS>GError *</RETURNS>
GQuark         domain,gint           code,const gchar   *message
</FUNCTION>
<FUNCTION>
<NAME>g_error_free</NAME>
<RETURNS>void  </RETURNS>
GError        *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_copy</NAME>
<RETURNS>GError *</RETURNS>
const GError  *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_matches</NAME>
<RETURNS>gboolean  </RETURNS>
const GError  *error,GQuark         domain,gint           code
</FUNCTION>
<FUNCTION>
<NAME>g_set_error</NAME>
<RETURNS>void  </RETURNS>
GError       **err,GQuark         domain,gint           code,const gchar   *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_propagate_error</NAME>
<RETURNS>void  </RETURNS>
GError       **dest,GError        *src
</FUNCTION>
<FUNCTION>
<NAME>g_clear_error</NAME>
<RETURNS>void  </RETURNS>
GError       **err
</FUNCTION>
<MACRO>
<NAME>G_GNUC_EXTENSION</NAME>
#  define G_GNUC_EXTENSION __extension__
</MACRO>
<MACRO>
<NAME>G_GNUC_EXTENSION</NAME>
#  define G_GNUC_EXTENSION
</MACRO>
<MACRO>
<NAME>G_E</NAME>
#define G_E     2.7182818284590452354E0
</MACRO>
<MACRO>
<NAME>G_LN2</NAME>
#define G_LN2   6.9314718055994530942E-1
</MACRO>
<MACRO>
<NAME>G_LN10</NAME>
#define G_LN10  2.3025850929940456840E0
</MACRO>
<MACRO>
<NAME>G_PI</NAME>
#define G_PI    3.14159265358979323846E0
</MACRO>
<MACRO>
<NAME>G_PI_2</NAME>
#define G_PI_2  1.57079632679489661923E0
</MACRO>
<MACRO>
<NAME>G_PI_4</NAME>
#define G_PI_4  0.78539816339744830962E0
</MACRO>
<MACRO>
<NAME>G_SQRT2</NAME>
#define G_SQRT2 1.4142135623730950488E0
</MACRO>
<MACRO>
<NAME>G_DIR_SEPARATOR</NAME>
#define G_DIR_SEPARATOR '\\'
</MACRO>
<MACRO>
<NAME>G_DIR_SEPARATOR_S</NAME>
#define G_DIR_SEPARATOR_S "\\"
</MACRO>
<MACRO>
<NAME>G_SEARCHPATH_SEPARATOR</NAME>
#define G_SEARCHPATH_SEPARATOR ';'
</MACRO>
<MACRO>
<NAME>G_SEARCHPATH_SEPARATOR_S</NAME>
#define G_SEARCHPATH_SEPARATOR_S ";"
</MACRO>
<MACRO>
<NAME>G_DIR_SEPARATOR</NAME>
#define G_DIR_SEPARATOR '/'
</MACRO>
<MACRO>
<NAME>G_DIR_SEPARATOR_S</NAME>
#define G_DIR_SEPARATOR_S "/"
</MACRO>
<MACRO>
<NAME>G_SEARCHPATH_SEPARATOR</NAME>
#define G_SEARCHPATH_SEPARATOR ':'
</MACRO>
<MACRO>
<NAME>G_SEARCHPATH_SEPARATOR_S</NAME>
#define G_SEARCHPATH_SEPARATOR_S ":"
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#    define NULL        (0L)
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#    define NULL        ((void*) 0)
</MACRO>
<MACRO>
<NAME>FALSE</NAME>
#define	FALSE	(0)
</MACRO>
<MACRO>
<NAME>TRUE</NAME>
#define	TRUE	(!FALSE)
</MACRO>
<MACRO>
<NAME>MAX</NAME>
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
</MACRO>
<MACRO>
<NAME>MIN</NAME>
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
</MACRO>
<MACRO>
<NAME>ABS</NAME>
#define ABS(a)	   (((a) < 0) ? -(a) : (a))
</MACRO>
<MACRO>
<NAME>CLAMP</NAME>
#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
</MACRO>
<MACRO>
<NAME>G_STRINGIFY</NAME>
#define G_STRINGIFY(macro_or_string)	G_STRINGIFY_ARG (macro_or_string)
</MACRO>
<MACRO>
<NAME>G_STRINGIFY_ARG</NAME>
#define	G_STRINGIFY_ARG(contents)	#contents
</MACRO>
<MACRO>
<NAME>G_STRLOC</NAME>
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__) ":" __PRETTY_FUNCTION__ "()"
</MACRO>
<MACRO>
<NAME>G_STRLOC</NAME>
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
</MACRO>
<MACRO>
<NAME>G_N_ELEMENTS</NAME>
#define G_N_ELEMENTS(arr)		(sizeof (arr) / sizeof ((arr)[0]))
</MACRO>
<MACRO>
<NAME>G_VA_COPY</NAME>
#  define G_VA_COPY(ap1, ap2)	  (*(ap1) = *(ap2))
</MACRO>
<MACRO>
<NAME>G_VA_COPY</NAME>
#  define G_VA_COPY(ap1, ap2)	  g_memmove ((ap1), (ap2), sizeof (va_list))
</MACRO>
<MACRO>
<NAME>G_VA_COPY</NAME>
#  define G_VA_COPY(ap1, ap2)	  ((ap1) = (ap2))
</MACRO>
<MACRO>
<NAME>G_STRUCT_OFFSET</NAME>
#define G_STRUCT_OFFSET(struct_type, member)	\
    ((glong) ((guint8*) &((struct_type*) 0)->member))
</MACRO>
<MACRO>
<NAME>G_STRUCT_MEMBER_P</NAME>
#define G_STRUCT_MEMBER_P(struct_p, struct_offset)   \
    ((gpointer) ((guint8*) (struct_p) + (glong) (struct_offset)))
</MACRO>
<MACRO>
<NAME>G_STRUCT_MEMBER</NAME>
#define G_STRUCT_MEMBER(member_type, struct_p, struct_offset)   \
    (*(member_type*) G_STRUCT_MEMBER_P ((struct_p), (struct_offset)))
</MACRO>
<MACRO>
<NAME>G_CAN_INLINE</NAME>
#  define G_CAN_INLINE 1
</MACRO>
<MACRO>
<NAME>inline</NAME>
#    define inline __inline__
</MACRO>
<MACRO>
<NAME>inline</NAME>
#    define inline __inline__
</MACRO>
<MACRO>
<NAME>inline</NAME>
#      define inline __inline
</MACRO>
<MACRO>
<NAME>inline</NAME>
#      define inline /* don't inline, then */
</MACRO>
<MACRO>
<NAME>G_INLINE_FUNC</NAME>
#      define G_INLINE_FUNC extern inline
</MACRO>
<MACRO>
<NAME>G_INLINE_FUNC</NAME>
#      define G_INLINE_FUNC extern
</MACRO>
<MACRO>
<NAME>G_INLINE_FUNC</NAME>
#      define G_INLINE_FUNC static inline
</MACRO>
<MACRO>
<NAME>G_INLINE_FUNC</NAME>
#      define G_INLINE_FUNC extern
</MACRO>
<MACRO>
<NAME>G_STMT_START</NAME>
#    define G_STMT_START	(void)(
</MACRO>
<MACRO>
<NAME>G_STMT_END</NAME>
#    define G_STMT_END		)
</MACRO>
<MACRO>
<NAME>G_STMT_START</NAME>
#      define G_STMT_START	if (1)
</MACRO>
<MACRO>
<NAME>G_STMT_END</NAME>
#      define G_STMT_END	else (void)0
</MACRO>
<MACRO>
<NAME>G_STMT_START</NAME>
#      define G_STMT_START	do
</MACRO>
<MACRO>
<NAME>G_STMT_END</NAME>
#      define G_STMT_END	while (0)
</MACRO>
<MACRO>
<NAME>G_GNUC_PRINTF</NAME>
#define G_GNUC_PRINTF( format_idx, arg_idx )	\
  __attribute__((format (printf, format_idx, arg_idx)))
</MACRO>
<MACRO>
<NAME>G_GNUC_SCANF</NAME>
#define G_GNUC_SCANF( format_idx, arg_idx )	\
  __attribute__((format (scanf, format_idx, arg_idx)))
</MACRO>
<MACRO>
<NAME>G_GNUC_FORMAT</NAME>
#define G_GNUC_FORMAT( arg_idx )		\
  __attribute__((format_arg (arg_idx)))
</MACRO>
<MACRO>
<NAME>G_GNUC_NORETURN</NAME>
#define G_GNUC_NORETURN				\
  __attribute__((noreturn))
</MACRO>
<MACRO>
<NAME>G_GNUC_CONST</NAME>
#define G_GNUC_CONST				\
  __attribute__((const))
</MACRO>
<MACRO>
<NAME>G_GNUC_UNUSED</NAME>
#define G_GNUC_UNUSED				\
  __attribute__((unused))
</MACRO>
<MACRO>
<NAME>G_GNUC_PRINTF</NAME>
#define G_GNUC_PRINTF( format_idx, arg_idx )
</MACRO>
<MACRO>
<NAME>G_GNUC_SCANF</NAME>
#define G_GNUC_SCANF( format_idx, arg_idx )
</MACRO>
<MACRO>
<NAME>G_GNUC_FORMAT</NAME>
#define G_GNUC_FORMAT( arg_idx )
</MACRO>
<MACRO>
<NAME>G_GNUC_NORETURN</NAME>
#define G_GNUC_NORETURN
</MACRO>
<MACRO>
<NAME>G_GNUC_CONST</NAME>
#define G_GNUC_CONST
</MACRO>
<MACRO>
<NAME>G_GNUC_UNUSED</NAME>
#define	G_GNUC_UNUSED
</MACRO>
<MACRO>
<NAME>G_GNUC_FUNCTION</NAME>
#define	G_GNUC_FUNCTION		__FUNCTION__
</MACRO>
<MACRO>
<NAME>G_GNUC_PRETTY_FUNCTION</NAME>
#define	G_GNUC_PRETTY_FUNCTION	__PRETTY_FUNCTION__
</MACRO>
<MACRO>
<NAME>G_GNUC_FUNCTION</NAME>
#define	G_GNUC_FUNCTION		""
</MACRO>
<MACRO>
<NAME>G_GNUC_PRETTY_FUNCTION</NAME>
#define	G_GNUC_PRETTY_FUNCTION	""
</MACRO>
<MACRO>
<NAME>ATEXIT</NAME>
# define ATEXIT(proc)	g_ATEXIT(proc)
</MACRO>
<MACRO>
<NAME>G_NATIVE_ATEXIT</NAME>
# define G_NATIVE_ATEXIT
</MACRO>
<MACRO>
<NAME>G_BREAKPOINT</NAME>
#define	G_BREAKPOINT()		G_STMT_START{ __asm__ __volatile__ ("int $03"); }G_STMT_END
</MACRO>
<MACRO>
<NAME>G_BREAKPOINT</NAME>
#define	G_BREAKPOINT()		G_STMT_START{ __asm__ __volatile__ ("bpt"); }G_STMT_END
</MACRO>
<MACRO>
<NAME>G_BREAKPOINT</NAME>
#define	G_BREAKPOINT()
</MACRO>
<MACRO>
<NAME>g_new</NAME>
#  define g_new(type, count)		(ALLOC (type, count))
</MACRO>
<MACRO>
<NAME>g_new0</NAME>
#  define g_new0(type, count)		(CALLOC (type, count))
</MACRO>
<MACRO>
<NAME>g_renew</NAME>
#  define g_renew(type, mem, count)	(REALLOC (mem, type, count))
</MACRO>
<MACRO>
<NAME>g_new</NAME>
#  define g_new(type, count)	  \
      ((type *) g_malloc ((unsigned) sizeof (type) * (count)))
</MACRO>
<MACRO>
<NAME>g_new0</NAME>
#  define g_new0(type, count)	  \
      ((type *) g_malloc0 ((unsigned) sizeof (type) * (count)))
</MACRO>
<MACRO>
<NAME>g_renew</NAME>
#  define g_renew(type, mem, count)	  \
      ((type *) g_realloc (mem, (unsigned) sizeof (type) * (count)))
</MACRO>
<MACRO>
<NAME>g_mem_chunk_create</NAME>
#define g_mem_chunk_create(type, pre_alloc, alloc_type)	( \
  g_mem_chunk_new (#type " mem chunks (" #pre_alloc ")", \
		   sizeof (type), \
		   sizeof (type) * (pre_alloc), \
		   (alloc_type)) \
)
</MACRO>
<MACRO>
<NAME>g_chunk_new</NAME>
#define g_chunk_new(type, chunk)	( \
  (type *) g_mem_chunk_alloc (chunk) \
)
</MACRO>
<MACRO>
<NAME>g_chunk_new0</NAME>
#define g_chunk_new0(type, chunk)	( \
  (type *) g_mem_chunk_alloc0 (chunk) \
)
</MACRO>
<MACRO>
<NAME>g_chunk_free</NAME>
#define g_chunk_free(mem, mem_chunk)	G_STMT_START { \
  g_mem_chunk_free ((mem_chunk), (mem)); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert</NAME>
#define g_assert(expr)
</MACRO>
<MACRO>
<NAME>g_assert_not_reached</NAME>
#define g_assert_not_reached()
</MACRO>
<MACRO>
<NAME>g_assert</NAME>
#define g_assert(expr)			G_STMT_START{		\
     if (!(expr))						\
       g_log (G_LOG_DOMAIN,					\
	      G_LOG_LEVEL_ERROR,				\
	      "file %s: line %d (%s): assertion failed: (%s)",	\
	      __FILE__,						\
	      __LINE__,						\
	      __PRETTY_FUNCTION__,				\
	      #expr);			}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_not_reached</NAME>
#define g_assert_not_reached()		G_STMT_START{		\
     g_log (G_LOG_DOMAIN,					\
	    G_LOG_LEVEL_ERROR,					\
	    "file %s: line %d (%s): should not be reached",	\
	    __FILE__,						\
	    __LINE__,						\
	    __PRETTY_FUNCTION__);	}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert</NAME>
#define g_assert(expr)			G_STMT_START{		\
     if (!(expr))						\
       g_log (G_LOG_DOMAIN,					\
	      G_LOG_LEVEL_ERROR,				\
	      "file %s: line %d: assertion failed: (%s)",	\
	      __FILE__,						\
	      __LINE__,						\
	      #expr);			}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_assert_not_reached</NAME>
#define g_assert_not_reached()		G_STMT_START{	\
     g_log (G_LOG_DOMAIN,				\
	    G_LOG_LEVEL_ERROR,				\
	    "file %s: line %d: should not be reached",	\
	    __FILE__,					\
	    __LINE__);		}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_if_fail</NAME>
#define g_return_if_fail(expr)
</MACRO>
<MACRO>
<NAME>g_return_val_if_fail</NAME>
#define g_return_val_if_fail(expr,val)
</MACRO>
<MACRO>
<NAME>g_return_if_reached</NAME>
#define g_return_if_reached() return
</MACRO>
<MACRO>
<NAME>g_return_val_if_reached</NAME>
#define g_return_val_if_reached(val) return (val)
</MACRO>
<MACRO>
<NAME>g_return_if_fail</NAME>
#define g_return_if_fail(expr)		G_STMT_START{			\
     if (!(expr))							\
       {								\
	 g_log (G_LOG_DOMAIN,						\
		G_LOG_LEVEL_CRITICAL,					\
		"file %s: line %d (%s): assertion `%s' failed",		\
		__FILE__,						\
		__LINE__,						\
		__PRETTY_FUNCTION__,					\
		#expr);							\
	 return;							\
       };				}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_val_if_fail</NAME>
#define g_return_val_if_fail(expr,val)	G_STMT_START{			\
     if (!(expr))							\
       {								\
	 g_log (G_LOG_DOMAIN,						\
		G_LOG_LEVEL_CRITICAL,					\
		"file %s: line %d (%s): assertion `%s' failed",		\
		__FILE__,						\
		__LINE__,						\
		__PRETTY_FUNCTION__,					\
		#expr);							\
	 return (val);							\
       };				}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_if_reached</NAME>
#define g_return_if_reached()		G_STMT_START{			\
     g_log (G_LOG_DOMAIN,						\
	    G_LOG_LEVEL_CRITICAL,					\
	    "file %s: line %d (%s): should not be reached",		\
	    __FILE__,							\
	    __LINE__,							\
	    __PRETTY_FUNCTION__);					\
     return;				}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_val_if_reached</NAME>
#define g_return_val_if_reached(val)	G_STMT_START{			\
     g_log (G_LOG_DOMAIN,						\
	    G_LOG_LEVEL_CRITICAL,					\
	    "file %s: line %d (%s): should not be reached",		\
	    __FILE__,							\
	    __LINE__,							\
	    __PRETTY_FUNCTION__);					\
     return (val);			}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_if_fail</NAME>
#define g_return_if_fail(expr)		G_STMT_START{		\
     if (!(expr))						\
       {							\
	 g_log (G_LOG_DOMAIN,					\
		G_LOG_LEVEL_CRITICAL,				\
		"file %s: line %d: assertion `%s' failed",	\
		__FILE__,					\
		__LINE__,					\
		#expr);						\
	 return;						\
       };				}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_val_if_fail</NAME>
#define g_return_val_if_fail(expr, val)	G_STMT_START{		\
     if (!(expr))						\
       {							\
	 g_log (G_LOG_DOMAIN,					\
		G_LOG_LEVEL_CRITICAL,				\
		"file %s: line %d: assertion `%s' failed",	\
		__FILE__,					\
		__LINE__,					\
		#expr);						\
	 return (val);						\
       };				}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_if_reached</NAME>
#define g_return_if_reached()		G_STMT_START{		\
     g_log (G_LOG_DOMAIN,					\
	    G_LOG_LEVEL_CRITICAL,				\
	    "file %s: line %d: should not be reached",		\
	    __FILE__,						\
	    __LINE__);						\
     return;				}G_STMT_END
</MACRO>
<MACRO>
<NAME>g_return_val_if_reached</NAME>
#define g_return_val_if_reached(val)	G_STMT_START{		\
     g_log (G_LOG_DOMAIN,					\
	    G_LOG_LEVEL_CRITICAL,				\
	    "file %s: line %d: should not be reached",		\
	    __FILE__,						\
	    __LINE__);						\
     return (val);			}G_STMT_END
</MACRO>
<TYPEDEF>
<NAME>gchar</NAME>
typedef char   gchar;
</TYPEDEF>
<TYPEDEF>
<NAME>gshort</NAME>
typedef short  gshort;
</TYPEDEF>
<TYPEDEF>
<NAME>glong</NAME>
typedef long   glong;
</TYPEDEF>
<TYPEDEF>
<NAME>gint</NAME>
typedef int    gint;
</TYPEDEF>
<TYPEDEF>
<NAME>gboolean</NAME>
typedef gint   gboolean;
</TYPEDEF>
<TYPEDEF>
<NAME>gstring</NAME>
typedef gchar* gstring;
</TYPEDEF>
<TYPEDEF>
<NAME>guchar</NAME>
typedef unsigned char	guchar;
</TYPEDEF>
<TYPEDEF>
<NAME>gushort</NAME>
typedef unsigned short	gushort;
</TYPEDEF>
<TYPEDEF>
<NAME>gulong</NAME>
typedef unsigned long	gulong;
</TYPEDEF>
<TYPEDEF>
<NAME>guint</NAME>
typedef unsigned int	guint;
</TYPEDEF>
<MACRO>
<NAME>G_GSHORT_FORMAT</NAME>
#define G_GSHORT_FORMAT  "hi"
</MACRO>
<MACRO>
<NAME>G_GUSHORT_FORMAT</NAME>
#define G_GUSHORT_FORMAT "hu"
</MACRO>
<MACRO>
<NAME>G_GINT_FORMAT</NAME>
#define G_GINT_FORMAT    "i"
</MACRO>
<MACRO>
<NAME>G_GUINT_FORMAT</NAME>
#define G_GUINT_FORMAT   "u"
</MACRO>
<MACRO>
<NAME>G_GLONG_FORMAT</NAME>
#define G_GLONG_FORMAT   "li"
</MACRO>
<MACRO>
<NAME>G_GULONG_FORMAT</NAME>
#define G_GULONG_FORMAT  "lu"
</MACRO>
<TYPEDEF>
<NAME>gfloat</NAME>
typedef float	gfloat;
</TYPEDEF>
<TYPEDEF>
<NAME>gdouble</NAME>
typedef double	gdouble;
</TYPEDEF>
<TYPEDEF>
<NAME>gldouble</NAME>
typedef long double gldouble;
</TYPEDEF>
<TYPEDEF>
<NAME>gldouble</NAME>
typedef double gldouble;
</TYPEDEF>
<TYPEDEF>
<NAME>gpointer</NAME>
typedef void* gpointer;
</TYPEDEF>
<TYPEDEF>
<NAME>gconstpointer</NAME>
typedef const void *gconstpointer;
</TYPEDEF>
<TYPEDEF>
<NAME>GQuark</NAME>
typedef guint32 GQuark;
</TYPEDEF>
<TYPEDEF>
<NAME>GTime</NAME>
typedef gint32	GTime;
</TYPEDEF>
<MACRO>
<NAME>G_LITTLE_ENDIAN</NAME>
#define G_LITTLE_ENDIAN 1234
</MACRO>
<MACRO>
<NAME>G_BIG_ENDIAN</NAME>
#define G_BIG_ENDIAN    4321
</MACRO>
<MACRO>
<NAME>G_PDP_ENDIAN</NAME>
#define G_PDP_ENDIAN    3412		/* unused, need specific PDP check */	
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE_CONSTANT</NAME>
#define GUINT16_SWAP_LE_BE_CONSTANT(val)	((guint16) ( \
    (((guint16) (val) & (guint16) 0x00ffU) << 8) | \
    (((guint16) (val) & (guint16) 0xff00U) >> 8)))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE_CONSTANT</NAME>
#define GUINT32_SWAP_LE_BE_CONSTANT(val)	((guint32) ( \
    (((guint32) (val) & (guint32) 0x000000ffU) << 24) | \
    (((guint32) (val) & (guint32) 0x0000ff00U) <<  8) | \
    (((guint32) (val) & (guint32) 0x00ff0000U) >>  8) | \
    (((guint32) (val) & (guint32) 0xff000000U) >> 24)))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE_X86</NAME>
#  define GUINT16_SWAP_LE_BE_X86(val) \
     (__extension__					\
      ({ register guint16 __v;				\
	 if (__builtin_constant_p (val))		\
	   __v = GUINT16_SWAP_LE_BE_CONSTANT (val);	\
	 else						\
	   __asm__ __const__ ("rorw $8, %w0"		\
			      : "=r" (__v)		\
			      : "0" ((guint16) (val)));	\
	__v; }))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE</NAME>
#  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_X86 (val))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE_X86</NAME>
#     define GUINT32_SWAP_LE_BE_X86(val) \
        (__extension__						\
         ({ register guint32 __v;				\
	    if (__builtin_constant_p (val))			\
	      __v = GUINT32_SWAP_LE_BE_CONSTANT (val);		\
	  else							\
	    __asm__ __const__ ("rorw $8, %w0\n\t"		\
			       "rorl $16, %0\n\t"		\
			       "rorw $8, %w0"			\
			       : "=r" (__v)			\
			       : "0" ((guint32) (val)));	\
	__v; }))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE_X86</NAME>
#     define GUINT32_SWAP_LE_BE_X86(val) \
        (__extension__						\
         ({ register guint32 __v;				\
	    if (__builtin_constant_p (val))			\
	      __v = GUINT32_SWAP_LE_BE_CONSTANT (val);		\
	  else							\
	    __asm__ __const__ ("bswap %0"			\
			       : "=r" (__v)			\
			       : "0" ((guint32) (val)));	\
	__v; }))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE</NAME>
#  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_X86 (val))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_BE</NAME>
#  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_BE</NAME>
#  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_CONSTANT (val))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE_CONSTANT</NAME>
#  define GUINT64_SWAP_LE_BE_CONSTANT(val)	((guint64) ( \
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0x00000000000000ffU)) << 56) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0x000000000000ff00U)) << 40) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0x0000000000ff0000U)) << 24) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0x00000000ff000000U)) <<  8) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0x000000ff00000000U)) >>  8) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0x0000ff0000000000U)) >> 24) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0x00ff000000000000U)) >> 40) |	\
      (((guint64) (val) &						\
	(guint64) G_GINT64_CONSTANT(0xff00000000000000U)) >> 56)))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE_X86</NAME>
#    define GUINT64_SWAP_LE_BE_X86(val) \
	(__extension__						\
	 ({ union { guint64 __ll;				\
		    guint32 __l[2]; } __r;			\
	    if (__builtin_constant_p (val))			\
	      __r.__ll = GUINT64_SWAP_LE_BE_CONSTANT (val);	\
	    else						\
	      {							\
	 	union { guint64 __ll;				\
			guint32 __l[2]; } __w;			\
		__w.__ll = ((guint64) val);			\
		__r.__l[0] = GUINT32_SWAP_LE_BE (__w.__l[1]);	\
		__r.__l[1] = GUINT32_SWAP_LE_BE (__w.__l[0]);	\
	      }							\
	  __r.__ll; }))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE</NAME>
#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_X86 (val))
</MACRO>
<MACRO>
<NAME>GUINT64_SWAP_LE_BE</NAME>
#    define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_CONSTANT(val))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_LE_PDP</NAME>
#define GUINT16_SWAP_LE_PDP(val)	((guint16) (val))
</MACRO>
<MACRO>
<NAME>GUINT16_SWAP_BE_PDP</NAME>
#define GUINT16_SWAP_BE_PDP(val)	(GUINT16_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_LE_PDP</NAME>
#define GUINT32_SWAP_LE_PDP(val)	((guint32) ( \
    (((guint32) (val) & (guint32) 0x0000ffffU) << 16) | \
    (((guint32) (val) & (guint32) 0xffff0000U) >> 16)))
</MACRO>
<MACRO>
<NAME>GUINT32_SWAP_BE_PDP</NAME>
#define GUINT32_SWAP_BE_PDP(val)	((guint32) ( \
    (((guint32) (val) & (guint32) 0x00ff00ffU) << 8) | \
    (((guint32) (val) & (guint32) 0xff00ff00U) >> 8)))
</MACRO>
<MACRO>
<NAME>GINT16_FROM_LE</NAME>
#define GINT16_FROM_LE(val)	(GINT16_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT16_FROM_LE</NAME>
#define GUINT16_FROM_LE(val)	(GUINT16_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT16_FROM_BE</NAME>
#define GINT16_FROM_BE(val)	(GINT16_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT16_FROM_BE</NAME>
#define GUINT16_FROM_BE(val)	(GUINT16_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT32_FROM_LE</NAME>
#define GINT32_FROM_LE(val)	(GINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_FROM_LE</NAME>
#define GUINT32_FROM_LE(val)	(GUINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT32_FROM_BE</NAME>
#define GINT32_FROM_BE(val)	(GINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_FROM_BE</NAME>
#define GUINT32_FROM_BE(val)	(GUINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT64_FROM_LE</NAME>
#define GINT64_FROM_LE(val)	(GINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT64_FROM_LE</NAME>
#define GUINT64_FROM_LE(val)	(GUINT64_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT64_FROM_BE</NAME>
#define GINT64_FROM_BE(val)	(GINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT64_FROM_BE</NAME>
#define GUINT64_FROM_BE(val)	(GUINT64_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GLONG_FROM_LE</NAME>
#define GLONG_FROM_LE(val)	(GLONG_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GULONG_FROM_LE</NAME>
#define GULONG_FROM_LE(val)	(GULONG_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GLONG_FROM_BE</NAME>
#define GLONG_FROM_BE(val)	(GLONG_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GULONG_FROM_BE</NAME>
#define GULONG_FROM_BE(val)	(GULONG_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT_FROM_LE</NAME>
#define GINT_FROM_LE(val)	(GINT_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT_FROM_LE</NAME>
#define GUINT_FROM_LE(val)	(GUINT_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT_FROM_BE</NAME>
#define GINT_FROM_BE(val)	(GINT_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT_FROM_BE</NAME>
#define GUINT_FROM_BE(val)	(GUINT_TO_BE (val))
</MACRO>
<MACRO>
<NAME>g_ntohl</NAME>
#define g_ntohl(val) (GUINT32_FROM_BE (val))
</MACRO>
<MACRO>
<NAME>g_ntohs</NAME>
#define g_ntohs(val) (GUINT16_FROM_BE (val))
</MACRO>
<MACRO>
<NAME>g_htonl</NAME>
#define g_htonl(val) (GUINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>g_htons</NAME>
#define g_htons(val) (GUINT16_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GLIB_VAR</NAME>
#    define GLIB_VAR __declspec(dllexport)
</MACRO>
<MACRO>
<NAME>GLIB_VAR</NAME>
#    define GLIB_VAR extern __declspec(dllimport)
</MACRO>
<MACRO>
<NAME>GLIB_VAR</NAME>
#  define GLIB_VAR extern
</MACRO>
<MACRO>
<NAME>GLIB_CHECK_VERSION</NAME>
#define GLIB_CHECK_VERSION(major,minor,micro)    \
    (GLIB_MAJOR_VERSION > (major) || \
     (GLIB_MAJOR_VERSION == (major) && GLIB_MINOR_VERSION > (minor)) || \
     (GLIB_MAJOR_VERSION == (major) && GLIB_MINOR_VERSION == (minor) && \
      GLIB_MICRO_VERSION >= (micro)))
</MACRO>
<STRUCT>
<NAME>GAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GArray</NAME>
</STRUCT>
<STRUCT>
<NAME>GByteArray</NAME>
</STRUCT>
<STRUCT>
<NAME>GCache</NAME>
</STRUCT>
<STRUCT>
<NAME>GCompletion</NAME>
</STRUCT>
<STRUCT>
<NAME>GData</NAME>
</STRUCT>
<STRUCT>
<NAME>GDebugKey</NAME>
</STRUCT>
<STRUCT>
<NAME>GHashTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GHook</NAME>
</STRUCT>
<STRUCT>
<NAME>GHookList</NAME>
</STRUCT>
<STRUCT>
<NAME>GList</NAME>
</STRUCT>
<STRUCT>
<NAME>GMemChunk</NAME>
</STRUCT>
<STRUCT>
<NAME>GNode</NAME>
</STRUCT>
<STRUCT>
<NAME>GPtrArray</NAME>
</STRUCT>
<STRUCT>
<NAME>GQueue</NAME>
</STRUCT>
<STRUCT>
<NAME>GRand</NAME>
</STRUCT>
<STRUCT>
<NAME>GRelation</NAME>
</STRUCT>
<STRUCT>
<NAME>GScanner</NAME>
</STRUCT>
<STRUCT>
<NAME>GScannerConfig</NAME>
</STRUCT>
<STRUCT>
<NAME>GSList</NAME>
</STRUCT>
<STRUCT>
<NAME>GString</NAME>
</STRUCT>
<STRUCT>
<NAME>GStringChunk</NAME>
</STRUCT>
<STRUCT>
<NAME>GTimer</NAME>
</STRUCT>
<STRUCT>
<NAME>GTrashStack</NAME>
</STRUCT>
<STRUCT>
<NAME>GTree</NAME>
</STRUCT>
<STRUCT>
<NAME>GTuples</NAME>
</STRUCT>
<STRUCT>
<NAME>GIOChannel</NAME>
</STRUCT>
<ENUM>
<NAME>GTraverseFlags</NAME>
typedef enum
{
  G_TRAVERSE_LEAFS	= 1 << 0,
  G_TRAVERSE_NON_LEAFS	= 1 << 1,
  G_TRAVERSE_ALL	= G_TRAVERSE_LEAFS | G_TRAVERSE_NON_LEAFS,
  G_TRAVERSE_MASK	= 0x03
} GTraverseFlags;
</ENUM>
<ENUM>
<NAME>GTraverseType</NAME>
typedef enum
{
  G_IN_ORDER,
  G_PRE_ORDER,
  G_POST_ORDER,
  G_LEVEL_ORDER
} GTraverseType;
</ENUM>
<MACRO>
<NAME>G_LOG_LEVEL_USER_SHIFT</NAME>
#define	G_LOG_LEVEL_USER_SHIFT	(8)
</MACRO>
<ENUM>
<NAME>GLogLevelFlags</NAME>
typedef enum
{
  /* log flags */
  G_LOG_FLAG_RECURSION		= 1 << 0,
  G_LOG_FLAG_FATAL		= 1 << 1,
  
  /* GLib log levels */
  G_LOG_LEVEL_ERROR		= 1 << 2,	/* always fatal */
  G_LOG_LEVEL_CRITICAL		= 1 << 3,
  G_LOG_LEVEL_WARNING		= 1 << 4,
  G_LOG_LEVEL_MESSAGE		= 1 << 5,
  G_LOG_LEVEL_INFO		= 1 << 6,
  G_LOG_LEVEL_DEBUG		= 1 << 7,
  
  G_LOG_LEVEL_MASK		= ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
} GLogLevelFlags;
</ENUM>
<MACRO>
<NAME>G_LOG_FATAL_MASK</NAME>
#define	G_LOG_FATAL_MASK	(G_LOG_FLAG_RECURSION | G_LOG_LEVEL_ERROR)
</MACRO>
<USER_FUNCTION>
<NAME>GCacheNewFunc</NAME>
<RETURNS>gpointer </RETURNS>
gpointer	key
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCacheDupFunc</NAME>
<RETURNS>gpointer </RETURNS>
gpointer	value
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCacheDestroyFunc</NAME>
<RETURNS>void </RETURNS>
gpointer	value
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCompareFunc</NAME>
<RETURNS>gint </RETURNS>
gconstpointer	a,
						 gconstpointer	b
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GCompletionFunc</NAME>
<RETURNS>gchar *</RETURNS>
gpointer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDestroyNotify</NAME>
<RETURNS>void </RETURNS>
gpointer	data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GDataForeachFunc</NAME>
<RETURNS>void </RETURNS>
GQuark		key_id,
						 gpointer	data,
						 gpointer	user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GFunc</NAME>
<RETURNS>void </RETURNS>
gpointer	data,
						 gpointer	user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHashFunc</NAME>
<RETURNS>guint </RETURNS>
gconstpointer	key
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GFreeFunc</NAME>
<RETURNS>void </RETURNS>
gpointer	data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHFunc</NAME>
<RETURNS>void </RETURNS>
gpointer	key,
						 gpointer	value,
						 gpointer	user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHRFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer	key,
						 gpointer	value,
						 gpointer	user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookCompareFunc</NAME>
<RETURNS>gint </RETURNS>
GHook		*new_hook,
						 GHook		*sibling
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookFindFunc</NAME>
<RETURNS>gboolean </RETURNS>
GHook		*hook,
						 gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookMarshaller</NAME>
<RETURNS>void </RETURNS>
GHook		*hook,
						 gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookCheckMarshaller</NAME>
<RETURNS>gboolean </RETURNS>
GHook		*hook,
						 gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookFunc</NAME>
<RETURNS>void </RETURNS>
gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookCheckFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer	 data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GHookFreeFunc</NAME>
<RETURNS>void </RETURNS>
GHookList      *hook_list,
						 GHook          *hook
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GLogFunc</NAME>
<RETURNS>void </RETURNS>
const gchar   *log_domain,
						 GLogLevelFlags	log_level,
						 const gchar   *message,
						 gpointer	user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GNodeTraverseFunc</NAME>
<RETURNS>gboolean </RETURNS>
GNode	       *node,
						 gpointer	data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GNodeForeachFunc</NAME>
<RETURNS>void </RETURNS>
GNode	       *node,
						 gpointer	data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GScannerMsgFunc</NAME>
<RETURNS>void </RETURNS>
GScanner      *scanner,
						 gchar	       *message,
						 gint		error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTraverseFunc</NAME>
<RETURNS>gint </RETURNS>
gpointer	key,
						 gpointer	value,
						 gpointer	data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GVoidFunc</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<STRUCT>
<NAME>GArray</NAME>
struct GArray
{
  gchar *data;
  guint len;
};
</STRUCT>
<STRUCT>
<NAME>GByteArray</NAME>
struct GByteArray
{
  guint8 *data;
  guint	  len;
};
</STRUCT>
<STRUCT>
<NAME>GDebugKey</NAME>
struct GDebugKey
{
  gchar *key;
  guint	 value;
};
</STRUCT>
<STRUCT>
<NAME>GList</NAME>
struct GList
{
  gpointer data;
  GList *next;
  GList *prev;
};
</STRUCT>
<STRUCT>
<NAME>GPtrArray</NAME>
struct GPtrArray
{
  gpointer *pdata;
  guint	    len;
};
</STRUCT>
<STRUCT>
<NAME>GQueue</NAME>
struct GQueue
{
  GList *head;
  GList *tail;
  guint  length;
};
</STRUCT>
<STRUCT>
<NAME>GSList</NAME>
struct GSList
{
  gpointer data;
  GSList *next;
};
</STRUCT>
<STRUCT>
<NAME>GString</NAME>
struct GString
{
  gchar *str;
  gint len;
};
</STRUCT>
<STRUCT>
<NAME>GTrashStack</NAME>
struct GTrashStack
{
  GTrashStack *next;
};
</STRUCT>
<STRUCT>
<NAME>GTuples</NAME>
struct GTuples
{
  guint len;
};
</STRUCT>
<MACRO>
<NAME>G_IEEE754_FLOAT_BIAS</NAME>
#define G_IEEE754_FLOAT_BIAS	(127)
</MACRO>
<MACRO>
<NAME>G_IEEE754_DOUBLE_BIAS</NAME>
#define G_IEEE754_DOUBLE_BIAS	(1023)
</MACRO>
<MACRO>
<NAME>G_LOG_2_BASE_10</NAME>
#define G_LOG_2_BASE_10		(0.30102999566398119521)
</MACRO>
<UNION>
<NAME>GFloatIEEE754</NAME>
union GFloatIEEE754
{
  gfloat v_float;
  struct {
    guint mantissa : 23;
    guint biased_exponent : 8;
    guint sign : 1;
  } mpn;
};
</UNION>
<UNION>
<NAME>GDoubleIEEE754</NAME>
union GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint mantissa_low : 32;
    guint mantissa_high : 20;
    guint biased_exponent : 11;
    guint sign : 1;
  } mpn;
};
</UNION>
<UNION>
<NAME>GFloatIEEE754</NAME>
union GFloatIEEE754
{
  gfloat v_float;
  struct {
    guint sign : 1;
    guint biased_exponent : 8;
    guint mantissa : 23;
  } mpn;
};
</UNION>
<UNION>
<NAME>GDoubleIEEE754</NAME>
union GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint sign : 1;
    guint biased_exponent : 11;
    guint mantissa_high : 20;
    guint mantissa_low : 32;
  } mpn;
};
</UNION>
<FUNCTION>
<NAME>g_list_push_allocator</NAME>
<RETURNS>void  </RETURNS>
GAllocator     *allocator
</FUNCTION>
<FUNCTION>
<NAME>g_list_pop_allocator</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_list_alloc</NAME>
<RETURNS>GList *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_list_free</NAME>
<RETURNS>void  </RETURNS>
GList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_list_free_1</NAME>
<RETURNS>void  </RETURNS>
GList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_list_append</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_list_prepend</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_list_insert</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,gpointer	 data,gint		 position
</FUNCTION>
<FUNCTION>
<NAME>g_list_insert_sorted</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,gpointer	 data,GCompareFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_list_concat</NAME>
<RETURNS>GList *</RETURNS>
GList		*list1,GList		*list2
</FUNCTION>
<FUNCTION>
<NAME>g_list_remove</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,gconstpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_list_remove_link</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,GList		*llink
</FUNCTION>
<FUNCTION>
<NAME>g_list_delete_link</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,GList		*link
</FUNCTION>
<FUNCTION>
<NAME>g_list_reverse</NAME>
<RETURNS>GList *</RETURNS>
GList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_list_copy</NAME>
<RETURNS>GList *</RETURNS>
GList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_list_nth</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,guint		 n
</FUNCTION>
<FUNCTION>
<NAME>g_list_find</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,gconstpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_list_find_custom</NAME>
<RETURNS>GList *</RETURNS>
GList		*list,gconstpointer	 data,GCompareFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_list_position</NAME>
<RETURNS>gint  </RETURNS>
GList		*list,GList		*llink
</FUNCTION>
<FUNCTION>
<NAME>g_list_index</NAME>
<RETURNS>gint  </RETURNS>
GList		*list,gconstpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_list_last</NAME>
<RETURNS>GList *</RETURNS>
GList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_list_first</NAME>
<RETURNS>GList *</RETURNS>
GList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_list_length</NAME>
<RETURNS>guint  </RETURNS>
GList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_list_foreach</NAME>
<RETURNS>void  </RETURNS>
GList		*list,GFunc		 func,gpointer	 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_list_sort</NAME>
<RETURNS>GList *</RETURNS>
GList          *list,GCompareFunc    compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_list_nth_data</NAME>
<RETURNS>gpointer  </RETURNS>
GList		*list,guint		 n
</FUNCTION>
<MACRO>
<NAME>g_list_previous</NAME>
#define g_list_previous(list)	((list) ? (((GList *)(list))->prev) : NULL)
</MACRO>
<MACRO>
<NAME>g_list_next</NAME>
#define g_list_next(list)	((list) ? (((GList *)(list))->next) : NULL)
</MACRO>
<FUNCTION>
<NAME>g_slist_push_allocator</NAME>
<RETURNS>void  </RETURNS>
GAllocator     *allocator
</FUNCTION>
<FUNCTION>
<NAME>g_slist_pop_allocator</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_slist_alloc</NAME>
<RETURNS>GSList *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_slist_free</NAME>
<RETURNS>void 	</RETURNS>
GSList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_free_1</NAME>
<RETURNS>void 	</RETURNS>
GSList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_append</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_prepend</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_insert</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,gpointer	 data,gint		 position
</FUNCTION>
<FUNCTION>
<NAME>g_slist_insert_sorted</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,gpointer	 data,GCompareFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_slist_insert_before</NAME>
<RETURNS>GSList *</RETURNS>
GSList         *slist,GSList         *sibling,gpointer        data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_concat</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list1,GSList		*list2
</FUNCTION>
<FUNCTION>
<NAME>g_slist_remove</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,gconstpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_remove_link</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,GSList		*link
</FUNCTION>
<FUNCTION>
<NAME>g_slist_delete_link</NAME>
<RETURNS>GSList *</RETURNS>
GSList         *list,GSList         *link
</FUNCTION>
<FUNCTION>
<NAME>g_slist_reverse</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_copy</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_nth</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,guint		 n
</FUNCTION>
<FUNCTION>
<NAME>g_slist_find</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,gconstpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_find_custom</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list,gconstpointer	 data,GCompareFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_slist_position</NAME>
<RETURNS>gint 	</RETURNS>
GSList		*list,GSList		*llink
</FUNCTION>
<FUNCTION>
<NAME>g_slist_index</NAME>
<RETURNS>gint 	</RETURNS>
GSList		*list,gconstpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_last</NAME>
<RETURNS>GSList *</RETURNS>
GSList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_length</NAME>
<RETURNS>guint 	</RETURNS>
GSList		*list
</FUNCTION>
<FUNCTION>
<NAME>g_slist_foreach</NAME>
<RETURNS>void 	</RETURNS>
GSList		*list,GFunc		 func,gpointer	 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_slist_sort</NAME>
<RETURNS>GSList *</RETURNS>
GSList          *list,GCompareFunc    compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_slist_nth_data</NAME>
<RETURNS>gpointer  </RETURNS>
GSList		*list,guint		 n
</FUNCTION>
<MACRO>
<NAME>g_slist_next</NAME>
#define  g_slist_next(slist)	((slist) ? (((GSList *)(slist))->next) : NULL)
</MACRO>
<FUNCTION>
<NAME>g_queue_new</NAME>
<RETURNS>GQueue *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_queue_free</NAME>
<RETURNS>void  </RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_head</NAME>
<RETURNS>void  </RETURNS>
GQueue  *queue,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_tail</NAME>
<RETURNS>void  </RETURNS>
GQueue  *queue,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_head</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_tail</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_is_empty</NAME>
<RETURNS>gboolean  </RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_head</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_peek_tail</NAME>
<RETURNS>gpointer  </RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_head_link</NAME>
<RETURNS>void  </RETURNS>
GQueue  *queue,GList   *link
</FUNCTION>
<FUNCTION>
<NAME>g_queue_push_tail_link</NAME>
<RETURNS>void  </RETURNS>
GQueue  *queue,GList   *link
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_head_link</NAME>
<RETURNS>GList *</RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_queue_pop_tail_link</NAME>
<RETURNS>GList *</RETURNS>
GQueue  *queue
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_new</NAME>
<RETURNS>GHashTable *</RETURNS>
GHashFunc	 hash_func,GCompareFunc	 key_compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_destroy</NAME>
<RETURNS>void 	</RETURNS>
GHashTable	*hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_insert</NAME>
<RETURNS>void 	</RETURNS>
GHashTable	*hash_table,gpointer	 key,gpointer	 value
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_remove</NAME>
<RETURNS>void 	</RETURNS>
GHashTable	*hash_table,gconstpointer	 key
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_lookup</NAME>
<RETURNS>gpointer  </RETURNS>
GHashTable	*hash_table,gconstpointer	 key
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_lookup_extended</NAME>
<RETURNS>gboolean  </RETURNS>
GHashTable	*hash_table,gconstpointer	 lookup_key,gpointer	*orig_key,gpointer	*value
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_foreach</NAME>
<RETURNS>void 	</RETURNS>
GHashTable	*hash_table,GHFunc		 func,gpointer	 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_foreach_remove</NAME>
<RETURNS>guint 	</RETURNS>
GHashTable	*hash_table,GHRFunc	 func,gpointer	 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_size</NAME>
<RETURNS>guint 	</RETURNS>
GHashTable	*hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_freeze</NAME>
<RETURNS>void 	</RETURNS>
GHashTable	*hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_hash_table_thaw</NAME>
<RETURNS>void 	</RETURNS>
GHashTable	*hash_table
</FUNCTION>
<FUNCTION>
<NAME>g_cache_new</NAME>
<RETURNS>GCache *</RETURNS>
GCacheNewFunc	   value_new_func,GCacheDestroyFunc  value_destroy_func,GCacheDupFunc	   key_dup_func,GCacheDestroyFunc  key_destroy_func,GHashFunc	   hash_key_func,GHashFunc	   hash_value_func,GCompareFunc	   key_compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_cache_destroy</NAME>
<RETURNS>void 	</RETURNS>
GCache		  *cache
</FUNCTION>
<FUNCTION>
<NAME>g_cache_insert</NAME>
<RETURNS>gpointer  </RETURNS>
GCache		  *cache,gpointer	   key
</FUNCTION>
<FUNCTION>
<NAME>g_cache_remove</NAME>
<RETURNS>void 	</RETURNS>
GCache		  *cache,gconstpointer	   value
</FUNCTION>
<FUNCTION>
<NAME>g_cache_key_foreach</NAME>
<RETURNS>void 	</RETURNS>
GCache		  *cache,GHFunc		   func,gpointer	   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_cache_value_foreach</NAME>
<RETURNS>void 	</RETURNS>
GCache		  *cache,GHFunc		   func,gpointer	   user_data
</FUNCTION>
<FUNCTION>
<NAME>g_tree_new</NAME>
<RETURNS>GTree *</RETURNS>
GCompareFunc	 key_compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_tree_destroy</NAME>
<RETURNS>void 	</RETURNS>
GTree		*tree
</FUNCTION>
<FUNCTION>
<NAME>g_tree_insert</NAME>
<RETURNS>void 	</RETURNS>
GTree		*tree,gpointer	 key,gpointer	 value
</FUNCTION>
<FUNCTION>
<NAME>g_tree_remove</NAME>
<RETURNS>void 	</RETURNS>
GTree		*tree,gconstpointer	 key
</FUNCTION>
<FUNCTION>
<NAME>g_tree_lookup</NAME>
<RETURNS>gpointer  </RETURNS>
GTree		*tree,gconstpointer	 key
</FUNCTION>
<FUNCTION>
<NAME>g_tree_traverse</NAME>
<RETURNS>void 	</RETURNS>
GTree		*tree,GTraverseFunc	 traverse_func,GTraverseType	 traverse_type,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_tree_search</NAME>
<RETURNS>gpointer  </RETURNS>
GTree		*tree,GCompareFunc	 search_func,gconstpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_tree_height</NAME>
<RETURNS>gint 	</RETURNS>
GTree		*tree
</FUNCTION>
<FUNCTION>
<NAME>g_tree_nnodes</NAME>
<RETURNS>gint 	</RETURNS>
GTree		*tree
</FUNCTION>
<STRUCT>
<NAME>GNode</NAME>
struct GNode
{
  gpointer data;
  GNode	  *next;
  GNode	  *prev;
  GNode	  *parent;
  GNode	  *children;
};
</STRUCT>
<MACRO>
<NAME>G_NODE_IS_ROOT</NAME>
#define	 G_NODE_IS_ROOT(node)	(((GNode*) (node))->parent == NULL && \
				 ((GNode*) (node))->prev == NULL && \
				 ((GNode*) (node))->next == NULL)
</MACRO>
<MACRO>
<NAME>G_NODE_IS_LEAF</NAME>
#define	 G_NODE_IS_LEAF(node)	(((GNode*) (node))->children == NULL)
</MACRO>
<FUNCTION>
<NAME>g_node_push_allocator</NAME>
<RETURNS>void  </RETURNS>
GAllocator       *allocator
</FUNCTION>
<FUNCTION>
<NAME>g_node_pop_allocator</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_node_new</NAME>
<RETURNS>GNode *</RETURNS>
gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_destroy</NAME>
<RETURNS>void 	</RETURNS>
GNode		  *root
</FUNCTION>
<FUNCTION>
<NAME>g_node_unlink</NAME>
<RETURNS>void 	</RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_copy</NAME>
<RETURNS>GNode *</RETURNS>
GNode            *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_insert</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *parent,gint		   position,GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_insert_before</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *parent,GNode		  *sibling,GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_prepend</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *parent,GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_n_nodes</NAME>
<RETURNS>guint 	</RETURNS>
GNode		  *root,GTraverseFlags	   flags
</FUNCTION>
<FUNCTION>
<NAME>g_node_get_root</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_is_ancestor</NAME>
<RETURNS>gboolean  </RETURNS>
GNode		  *node,GNode		  *descendant
</FUNCTION>
<FUNCTION>
<NAME>g_node_depth</NAME>
<RETURNS>guint 	</RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_find</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *root,GTraverseType	   order,GTraverseFlags	   flags,gpointer	   data
</FUNCTION>
<MACRO>
<NAME>g_node_append</NAME>
#define g_node_append(parent, node)				\
     g_node_insert_before ((parent), NULL, (node))
</MACRO>
<MACRO>
<NAME>g_node_insert_data</NAME>
#define	g_node_insert_data(parent, position, data)		\
     g_node_insert ((parent), (position), g_node_new (data))
</MACRO>
<MACRO>
<NAME>g_node_insert_data_before</NAME>
#define	g_node_insert_data_before(parent, sibling, data)	\
     g_node_insert_before ((parent), (sibling), g_node_new (data))
</MACRO>
<MACRO>
<NAME>g_node_prepend_data</NAME>
#define	g_node_prepend_data(parent, data)			\
     g_node_prepend ((parent), g_node_new (data))
</MACRO>
<MACRO>
<NAME>g_node_append_data</NAME>
#define	g_node_append_data(parent, data)			\
     g_node_insert_before ((parent), NULL, g_node_new (data))
</MACRO>
<FUNCTION>
<NAME>g_node_traverse</NAME>
<RETURNS>void 	</RETURNS>
GNode		  *root,GTraverseType	   order,GTraverseFlags	   flags,gint		   max_depth,GNodeTraverseFunc func,gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_max_height</NAME>
<RETURNS>guint 	</RETURNS>
GNode *root
</FUNCTION>
<FUNCTION>
<NAME>g_node_children_foreach</NAME>
<RETURNS>void 	</RETURNS>
GNode		  *node,GTraverseFlags   flags,GNodeForeachFunc func,gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_reverse_children</NAME>
<RETURNS>void 	</RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_n_children</NAME>
<RETURNS>guint 	</RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_nth_child</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *node,guint		   n
</FUNCTION>
<FUNCTION>
<NAME>g_node_last_child</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_find_child</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *node,GTraverseFlags   flags,gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_child_position</NAME>
<RETURNS>gint 	</RETURNS>
GNode		  *node,GNode		  *child
</FUNCTION>
<FUNCTION>
<NAME>g_node_child_index</NAME>
<RETURNS>gint 	</RETURNS>
GNode		  *node,gpointer	   data
</FUNCTION>
<FUNCTION>
<NAME>g_node_first_sibling</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *node
</FUNCTION>
<FUNCTION>
<NAME>g_node_last_sibling</NAME>
<RETURNS>GNode *</RETURNS>
GNode		  *node
</FUNCTION>
<MACRO>
<NAME>g_node_prev_sibling</NAME>
#define	 g_node_prev_sibling(node)	((node) ? \
					 ((GNode*) (node))->prev : NULL)
</MACRO>
<MACRO>
<NAME>g_node_next_sibling</NAME>
#define	 g_node_next_sibling(node)	((node) ? \
					 ((GNode*) (node))->next : NULL)
</MACRO>
<MACRO>
<NAME>g_node_first_child</NAME>
#define	 g_node_first_child(node)	((node) ? \
					 ((GNode*) (node))->children : NULL)
</MACRO>
<MACRO>
<NAME>G_HOOK_FLAG_USER_SHIFT</NAME>
#define G_HOOK_FLAG_USER_SHIFT	(4)
</MACRO>
<ENUM>
<NAME>GHookFlagMask</NAME>
typedef enum
{
  G_HOOK_FLAG_ACTIVE	= 1 << 0,
  G_HOOK_FLAG_IN_CALL	= 1 << 1,
  G_HOOK_FLAG_MASK	= 0x0f
} GHookFlagMask;
</ENUM>
<MACRO>
<NAME>G_HOOK_DEFERRED_DESTROY</NAME>
#define	G_HOOK_DEFERRED_DESTROY	((GHookFreeFunc) 0x01)
</MACRO>
<STRUCT>
<NAME>GHookList</NAME>
struct GHookList
{
  guint		 seq_id;
  guint		 hook_size;
  guint		 is_setup : 1;
  GHook		*hooks;
  GMemChunk	*hook_memchunk;
  GHookFreeFunc	 hook_free; /* virtual function */
  GHookFreeFunc	 hook_destroy; /* virtual function */
};
</STRUCT>
<STRUCT>
<NAME>GHook</NAME>
struct GHook
{
  gpointer	 data;
  GHook		*next;
  GHook		*prev;
  guint		 ref_count;
  guint		 hook_id;
  guint		 flags;
  gpointer	 func;
  GDestroyNotify destroy;
};
</STRUCT>
<MACRO>
<NAME>G_HOOK_ACTIVE</NAME>
#define	G_HOOK_ACTIVE(hook)		((((GHook*) hook)->flags & \
					  G_HOOK_FLAG_ACTIVE) != 0)
</MACRO>
<MACRO>
<NAME>G_HOOK_IN_CALL</NAME>
#define	G_HOOK_IN_CALL(hook)		((((GHook*) hook)->flags & \
					  G_HOOK_FLAG_IN_CALL) != 0)
</MACRO>
<MACRO>
<NAME>G_HOOK_IS_VALID</NAME>
#define G_HOOK_IS_VALID(hook)		(((GHook*) hook)->hook_id != 0 && \
					 G_HOOK_ACTIVE (hook))
</MACRO>
<MACRO>
<NAME>G_HOOK_IS_UNLINKED</NAME>
#define G_HOOK_IS_UNLINKED(hook)	(((GHook*) hook)->next == NULL && \
					 ((GHook*) hook)->prev == NULL && \
					 ((GHook*) hook)->hook_id == 0 && \
					 ((GHook*) hook)->ref_count == 0)
</MACRO>
<FUNCTION>
<NAME>g_hook_list_init</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,guint			 hook_size
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_clear</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list
</FUNCTION>
<FUNCTION>
<NAME>g_hook_alloc</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list
</FUNCTION>
<FUNCTION>
<NAME>g_hook_free</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_ref</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_unref</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_destroy</NAME>
<RETURNS>gboolean  </RETURNS>
GHookList		*hook_list,guint			 hook_id
</FUNCTION>
<FUNCTION>
<NAME>g_hook_destroy_link</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_prepend</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_insert_before</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,GHook			*sibling,GHook			*hook
</FUNCTION>
<FUNCTION>
<NAME>g_hook_insert_sorted</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,GHook			*hook,GHookCompareFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_hook_get</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list,guint			 hook_id
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list,gboolean		 need_valids,GHookFindFunc		 func,gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find_data</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list,gboolean		 need_valids,gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find_func</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list,gboolean		 need_valids,gpointer		 func
</FUNCTION>
<FUNCTION>
<NAME>g_hook_find_func_data</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list,gboolean		 need_valids,gpointer		 func,gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_first_valid</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list,gboolean		 may_be_in_call
</FUNCTION>
<FUNCTION>
<NAME>g_hook_next_valid</NAME>
<RETURNS>GHook *</RETURNS>
GHookList		*hook_list,GHook			*hook,gboolean		 may_be_in_call
</FUNCTION>
<FUNCTION>
<NAME>g_hook_compare_ids</NAME>
<RETURNS>gint 	</RETURNS>
GHook			*new_hook,GHook			*sibling
</FUNCTION>
<MACRO>
<NAME>g_hook_append</NAME>
#define	 g_hook_append( hook_list, hook )  \
     g_hook_insert_before ((hook_list), NULL, (hook))
</MACRO>
<FUNCTION>
<NAME>g_hook_list_invoke</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,gboolean		 may_recurse
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_invoke_check</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,gboolean		 may_recurse
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_marshal</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,gboolean		 may_recurse,GHookMarshaller	 marshaller,gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_hook_list_marshal_check</NAME>
<RETURNS>void 	</RETURNS>
GHookList		*hook_list,gboolean		 may_recurse,GHookCheckMarshaller	 marshaller,gpointer		 data
</FUNCTION>
<FUNCTION>
<NAME>g_on_error_query</NAME>
<RETURNS>void  </RETURNS>
const gchar *prg_name
</FUNCTION>
<FUNCTION>
<NAME>g_on_error_stack_trace</NAME>
<RETURNS>void  </RETURNS>
const gchar *prg_name
</FUNCTION>
<VARIABLE>
<NAME>g_log_domain_glib</NAME>
extern	        const gchar		*g_log_domain_glib;
</VARIABLE>
<FUNCTION>
<NAME>g_log_set_handler</NAME>
<RETURNS>guint 	</RETURNS>
const gchar	*log_domain,GLogLevelFlags	 log_levels,GLogFunc	 log_func,gpointer	 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_log_remove_handler</NAME>
<RETURNS>void 	</RETURNS>
const gchar	*log_domain,guint		 handler_id
</FUNCTION>
<FUNCTION>
<NAME>g_log_default_handler</NAME>
<RETURNS>void 	</RETURNS>
const gchar	*log_domain,GLogLevelFlags	 log_level,const gchar	*message,gpointer	 unused_data
</FUNCTION>
<FUNCTION>
<NAME>g_log</NAME>
<RETURNS>void 	</RETURNS>
const gchar	*log_domain,GLogLevelFlags	 log_level,const gchar	*format,...
</FUNCTION>
<FUNCTION>
<NAME>g_logv</NAME>
<RETURNS>void 	</RETURNS>
const gchar	*log_domain,GLogLevelFlags	 log_level,const gchar	*format,va_list	 args
</FUNCTION>
<FUNCTION>
<NAME>g_log_set_fatal_mask</NAME>
<RETURNS>GLogLevelFlags 	</RETURNS>
const gchar	*log_domain,GLogLevelFlags	 fatal_mask
</FUNCTION>
<FUNCTION>
<NAME>g_log_set_always_fatal</NAME>
<RETURNS>GLogLevelFlags 	</RETURNS>
GLogLevelFlags	 fatal_mask
</FUNCTION>
<MACRO>
<NAME>G_LOG_DOMAIN</NAME>
#define	G_LOG_DOMAIN	((gchar*) 0)
</MACRO>
<MACRO>
<NAME>g_error</NAME>
#define	g_error(...)	g_log (G_LOG_DOMAIN,         \
			       G_LOG_LEVEL_ERROR,    \
			       __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_message</NAME>
#define	g_message(...)	g_log (G_LOG_DOMAIN,         \
			       G_LOG_LEVEL_MESSAGE,  \
			       __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_critical</NAME>
#define	g_critical(...)	g_log (G_LOG_DOMAIN,         \
			       G_LOG_LEVEL_CRITICAL, \
			       __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_warning</NAME>
#define	g_warning(...)	g_log (G_LOG_DOMAIN,         \
			       G_LOG_LEVEL_WARNING,  \
			       __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>g_error</NAME>
#define	g_error(format...)	g_log (G_LOG_DOMAIN,         \
				       G_LOG_LEVEL_ERROR,    \
				       format)
</MACRO>
<MACRO>
<NAME>g_message</NAME>
#define	g_message(format...)	g_log (G_LOG_DOMAIN,         \
				       G_LOG_LEVEL_MESSAGE,  \
				       format)
</MACRO>
<MACRO>
<NAME>g_critical</NAME>
#define	g_critical(format...)	g_log (G_LOG_DOMAIN,         \
				       G_LOG_LEVEL_CRITICAL, \
				       format)
</MACRO>
<MACRO>
<NAME>g_warning</NAME>
#define	g_warning(format...)	g_log (G_LOG_DOMAIN,         \
				       G_LOG_LEVEL_WARNING,  \
				       format)
</MACRO>
<USER_FUNCTION>
<NAME>GPrintFunc</NAME>
<RETURNS>void </RETURNS>
const gchar	*string
</USER_FUNCTION>
<FUNCTION>
<NAME>g_print</NAME>
<RETURNS>void 	</RETURNS>
const gchar	*format,...
</FUNCTION>
<FUNCTION>
<NAME>g_set_print_handler</NAME>
<RETURNS>GPrintFunc 	</RETURNS>
GPrintFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_printerr</NAME>
<RETURNS>void 	</RETURNS>
const gchar	*format,...
</FUNCTION>
<FUNCTION>
<NAME>g_set_printerr_handler</NAME>
<RETURNS>GPrintFunc 	</RETURNS>
GPrintFunc	 func
</FUNCTION>
<USER_FUNCTION>
<NAME>GErrorFunc</NAME>
<RETURNS>void </RETURNS>
const gchar *str
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GWarningFunc</NAME>
<RETURNS>void </RETURNS>
const gchar *str
</USER_FUNCTION>
<FUNCTION>
<NAME>g_set_error_handler</NAME>
<RETURNS>GErrorFunc  </RETURNS>
GErrorFunc	 func
</FUNCTION>
<FUNCTION>
<NAME>g_set_warning_handler</NAME>
<RETURNS>GWarningFunc  </RETURNS>
GWarningFunc func
</FUNCTION>
<FUNCTION>
<NAME>g_set_message_handler</NAME>
<RETURNS>GPrintFunc  </RETURNS>
GPrintFunc func
</FUNCTION>
<MACRO>
<NAME>g_malloc</NAME>
#define g_malloc(size)	     ((gpointer) MALLOC (size))
</MACRO>
<MACRO>
<NAME>g_malloc0</NAME>
#define g_malloc0(size)	     ((gpointer) CALLOC (char, size))
</MACRO>
<MACRO>
<NAME>g_realloc</NAME>
#define g_realloc(mem,size)  ((gpointer) REALLOC (mem, char, size))
</MACRO>
<MACRO>
<NAME>g_free</NAME>
#define g_free(mem)	     FREE (mem)
</MACRO>
<FUNCTION>
<NAME>g_malloc</NAME>
<RETURNS>gpointer  </RETURNS>
gulong	  size
</FUNCTION>
<FUNCTION>
<NAME>g_malloc0</NAME>
<RETURNS>gpointer  </RETURNS>
gulong	  size
</FUNCTION>
<FUNCTION>
<NAME>g_realloc</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer  mem,gulong	  size
</FUNCTION>
<FUNCTION>
<NAME>g_free</NAME>
<RETURNS>void 	</RETURNS>
gpointer  mem
</FUNCTION>
<FUNCTION>
<NAME>g_mem_profile</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_mem_check</NAME>
<RETURNS>void 	</RETURNS>
gpointer  mem
</FUNCTION>
<FUNCTION>
<NAME>g_allocator_new</NAME>
<RETURNS>GAllocator *</RETURNS>
const gchar  *name,guint         n_preallocs
</FUNCTION>
<FUNCTION>
<NAME>g_allocator_free</NAME>
<RETURNS>void  </RETURNS>
GAllocator   *allocator
</FUNCTION>
<MACRO>
<NAME>G_ALLOCATOR_LIST</NAME>
#define	G_ALLOCATOR_LIST	(1)
</MACRO>
<MACRO>
<NAME>G_ALLOCATOR_SLIST</NAME>
#define	G_ALLOCATOR_SLIST	(2)
</MACRO>
<MACRO>
<NAME>G_ALLOCATOR_NODE</NAME>
#define	G_ALLOCATOR_NODE	(3)
</MACRO>
<MACRO>
<NAME>G_ALLOC_ONLY</NAME>
#define G_ALLOC_ONLY	  1
</MACRO>
<MACRO>
<NAME>G_ALLOC_AND_FREE</NAME>
#define G_ALLOC_AND_FREE  2
</MACRO>
<FUNCTION>
<NAME>g_mem_chunk_new</NAME>
<RETURNS>GMemChunk *</RETURNS>
gchar	  *name,gint	   atom_size,gulong	   area_size,gint	   type
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_destroy</NAME>
<RETURNS>void 	</RETURNS>
GMemChunk *mem_chunk
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_alloc</NAME>
<RETURNS>gpointer  </RETURNS>
GMemChunk *mem_chunk
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_alloc0</NAME>
<RETURNS>gpointer  </RETURNS>
GMemChunk *mem_chunk
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_free</NAME>
<RETURNS>void 	</RETURNS>
GMemChunk *mem_chunk,gpointer   mem
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_clean</NAME>
<RETURNS>void 	</RETURNS>
GMemChunk *mem_chunk
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_reset</NAME>
<RETURNS>void 	</RETURNS>
GMemChunk *mem_chunk
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_print</NAME>
<RETURNS>void 	</RETURNS>
GMemChunk *mem_chunk
</FUNCTION>
<FUNCTION>
<NAME>g_mem_chunk_info</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_blow_chunks</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_MICROSEC</NAME>
#define G_MICROSEC 1000000
</MACRO>
<FUNCTION>
<NAME>g_timer_new</NAME>
<RETURNS>GTimer *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_timer_destroy</NAME>
<RETURNS>void 	</RETURNS>
GTimer	 *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_start</NAME>
<RETURNS>void 	</RETURNS>
GTimer	 *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_stop</NAME>
<RETURNS>void 	</RETURNS>
GTimer	 *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_reset</NAME>
<RETURNS>void 	</RETURNS>
GTimer	 *timer
</FUNCTION>
<FUNCTION>
<NAME>g_timer_elapsed</NAME>
<RETURNS>gdouble  </RETURNS>
GTimer	 *timer,gulong	 *microseconds
</FUNCTION>
<FUNCTION>
<NAME>g_usleep</NAME>
<RETURNS>void  </RETURNS>
gulong microseconds
</FUNCTION>
<MACRO>
<NAME>G_STR_DELIMITERS</NAME>
#define	 G_STR_DELIMITERS	"_-|> <."
</MACRO>
<FUNCTION>
<NAME>g_strdelimit</NAME>
<RETURNS>gchar *</RETURNS>
gchar	     *string,const gchar *delimiters,gchar	      new_delimiter
</FUNCTION>
<FUNCTION>
<NAME>g_strcanon</NAME>
<RETURNS>gchar *</RETURNS>
gchar       *string,const gchar *valid_chars,gchar        subsitutor
</FUNCTION>
<FUNCTION>
<NAME>g_strtod</NAME>
<RETURNS>gdouble 	</RETURNS>
const gchar *nptr,gchar	    **endptr
</FUNCTION>
<FUNCTION>
<NAME>g_strerror</NAME>
<RETURNS>gchar *</RETURNS>
gint	      errnum
</FUNCTION>
<FUNCTION>
<NAME>g_strsignal</NAME>
<RETURNS>gchar *</RETURNS>
gint	      signum
</FUNCTION>
<FUNCTION>
<NAME>g_strcasecmp</NAME>
<RETURNS>gint 	</RETURNS>
const gchar *s1,const gchar *s2
</FUNCTION>
<FUNCTION>
<NAME>g_strncasecmp</NAME>
<RETURNS>gint 	</RETURNS>
const gchar *s1,const gchar *s2,guint 	      n
</FUNCTION>
<FUNCTION>
<NAME>g_strdown</NAME>
<RETURNS>gchar *</RETURNS>
gchar	     *string
</FUNCTION>
<FUNCTION>
<NAME>g_strup</NAME>
<RETURNS>gchar *</RETURNS>
gchar	     *string
</FUNCTION>
<FUNCTION>
<NAME>g_strreverse</NAME>
<RETURNS>gchar *</RETURNS>
gchar	     *string
</FUNCTION>
<FUNCTION>
<NAME>g_strlcpy</NAME>
<RETURNS>gsize 	</RETURNS>
gchar	     *dest,const gchar *src,gsize        dest_size
</FUNCTION>
<FUNCTION>
<NAME>g_strlcat</NAME>
<RETURNS>gsize 	</RETURNS>
gchar	     *dest,const gchar *src,gsize        dest_size
</FUNCTION>
<FUNCTION>
<NAME>g_strchug</NAME>
<RETURNS>gchar *</RETURNS>
gchar        *string
</FUNCTION>
<FUNCTION>
<NAME>g_strchomp</NAME>
<RETURNS>gchar *</RETURNS>
gchar        *string
</FUNCTION>
<MACRO>
<NAME>g_strstrip</NAME>
#define g_strstrip( string )	g_strchomp (g_strchug (string))
</MACRO>
<FUNCTION>
<NAME>g_strdup</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *str
</FUNCTION>
<FUNCTION>
<NAME>g_strdup_printf</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_strdup_vprintf</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *format,va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_strndup</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *str,guint	      n
</FUNCTION>
<FUNCTION>
<NAME>g_strnfill</NAME>
<RETURNS>gchar *</RETURNS>
guint	      length,gchar	      fill_char
</FUNCTION>
<FUNCTION>
<NAME>g_strconcat</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *string1,...
</FUNCTION>
<FUNCTION>
<NAME>g_strjoin</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *separator,...
</FUNCTION>
<FUNCTION>
<NAME>g_strcompress</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *source
</FUNCTION>
<FUNCTION>
<NAME>g_filename_to_utf8</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *opsysstring
</FUNCTION>
<FUNCTION>
<NAME>g_filename_from_utf8</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *utf8string
</FUNCTION>
<FUNCTION>
<NAME>g_strescape</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *source,const gchar *exceptions
</FUNCTION>
<FUNCTION>
<NAME>g_memdup</NAME>
<RETURNS>gpointer  </RETURNS>
gconstpointer mem,guint	       byte_size
</FUNCTION>
<FUNCTION>
<NAME>g_strsplit</NAME>
<RETURNS>gchar **</RETURNS>
const gchar  *string,const gchar  *delimiter,gint          max_tokens
</FUNCTION>
<FUNCTION>
<NAME>g_strjoinv</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *separator,gchar       **str_array
</FUNCTION>
<FUNCTION>
<NAME>g_strfreev</NAME>
<RETURNS>void  </RETURNS>
gchar       **str_array
</FUNCTION>
<FUNCTION>
<NAME>g_printf_string_upper_bound</NAME>
<RETURNS>guint 	</RETURNS>
const gchar* format,va_list	  args
</FUNCTION>
<FUNCTION>
<NAME>g_get_user_name</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_real_name</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_home_dir</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_tmp_dir</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_get_prgname</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_set_prgname</NAME>
<RETURNS>void 	</RETURNS>
const gchar *prgname
</FUNCTION>
<FUNCTION>
<NAME>g_parse_debug_string</NAME>
<RETURNS>guint 	</RETURNS>
const gchar *string,GDebugKey   *keys,guint	      nkeys
</FUNCTION>
<FUNCTION>
<NAME>g_snprintf</NAME>
<RETURNS>gint 	</RETURNS>
gchar	     *string,gulong	      n,gchar const *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_vsnprintf</NAME>
<RETURNS>gint 	</RETURNS>
gchar	     *string,gulong	      n,gchar const *format,va_list      args
</FUNCTION>
<FUNCTION>
<NAME>g_path_is_absolute</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_path_skip_root</NAME>
<RETURNS>gchar *</RETURNS>
gchar       *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_basename</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_dirname</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_get_current_dir</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_path_get_basename</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_path_get_dirname</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>g_getenv</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *variable
</FUNCTION>
<FUNCTION>
<NAME>g_atexit</NAME>
<RETURNS>void 	</RETURNS>
GVoidFunc    func
</FUNCTION>
<FUNCTION>
<NAME>g_bit_nth_lsf</NAME>
<RETURNS>gint 	</RETURNS>
guint32 mask,gint    nth_bit
</FUNCTION>
<FUNCTION>
<NAME>g_bit_nth_msf</NAME>
<RETURNS>gint 	</RETURNS>
guint32 mask,gint    nth_bit
</FUNCTION>
<FUNCTION>
<NAME>g_bit_storage</NAME>
<RETURNS>guint 	</RETURNS>
guint number
</FUNCTION>
<FUNCTION>
<NAME>g_trash_stack_push</NAME>
<RETURNS>void 	</RETURNS>
GTrashStack **stack_p,gpointer      data_p
</FUNCTION>
<FUNCTION>
<NAME>g_trash_stack_pop</NAME>
<RETURNS>gpointer 	</RETURNS>
GTrashStack **stack_p
</FUNCTION>
<FUNCTION>
<NAME>g_trash_stack_peek</NAME>
<RETURNS>gpointer 	</RETURNS>
GTrashStack **stack_p
</FUNCTION>
<FUNCTION>
<NAME>g_trash_stack_height</NAME>
<RETURNS>guint 	</RETURNS>
GTrashStack **stack_p
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_new</NAME>
<RETURNS>GStringChunk *</RETURNS>
gint size
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_free</NAME>
<RETURNS>void 	</RETURNS>
GStringChunk *chunk
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_insert</NAME>
<RETURNS>gchar *</RETURNS>
GStringChunk *chunk,const gchar	 *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_chunk_insert_const</NAME>
<RETURNS>gchar *</RETURNS>
GStringChunk *chunk,const gchar	 *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_new</NAME>
<RETURNS>GString *</RETURNS>
const gchar	 *init
</FUNCTION>
<FUNCTION>
<NAME>g_string_sized_new</NAME>
<RETURNS>GString *</RETURNS>
guint		  dfl_size
</FUNCTION>
<FUNCTION>
<NAME>g_string_free</NAME>
<RETURNS>gchar *</RETURNS>
GString	 *string,gboolean	  free_segment
</FUNCTION>
<FUNCTION>
<NAME>g_string_equal</NAME>
<RETURNS>gboolean  </RETURNS>
const GString	 *v,const GString 	 *v2
</FUNCTION>
<FUNCTION>
<NAME>g_string_hash</NAME>
<RETURNS>guint  </RETURNS>
const GString   *str
</FUNCTION>
<FUNCTION>
<NAME>g_string_assign</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,const gchar	 *rval
</FUNCTION>
<FUNCTION>
<NAME>g_string_truncate</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,guint		  len
</FUNCTION>
<FUNCTION>
<NAME>g_string_insert_len</NAME>
<RETURNS>GString *</RETURNS>
GString         *string,gint             pos,const gchar     *val,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_string_append</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,const gchar	 *val
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_len</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,const gchar	 *val,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_string_append_c</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,gchar		  c
</FUNCTION>
<FUNCTION>
<NAME>g_string_prepend</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,const gchar	 *val
</FUNCTION>
<FUNCTION>
<NAME>g_string_prepend_c</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,gchar		  c
</FUNCTION>
<FUNCTION>
<NAME>g_string_prepend_len</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,const gchar	 *val,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_string_insert</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,gint		  pos,const gchar	 *val
</FUNCTION>
<FUNCTION>
<NAME>g_string_insert_c</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,gint		  pos,gchar		  c
</FUNCTION>
<FUNCTION>
<NAME>g_string_erase</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string,gint		  pos,gint		  len
</FUNCTION>
<FUNCTION>
<NAME>g_string_down</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_up</NAME>
<RETURNS>GString *</RETURNS>
GString	 *string
</FUNCTION>
<FUNCTION>
<NAME>g_string_sprintf</NAME>
<RETURNS>void  </RETURNS>
GString	 *string,const gchar	 *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_string_sprintfa</NAME>
<RETURNS>void  </RETURNS>
GString	 *string,const gchar	 *format,...
</FUNCTION>
<MACRO>
<NAME>g_array_append_val</NAME>
#define g_array_append_val(a,v)	  g_array_append_vals (a, &v, 1)
</MACRO>
<MACRO>
<NAME>g_array_prepend_val</NAME>
#define g_array_prepend_val(a,v)  g_array_prepend_vals (a, &v, 1)
</MACRO>
<MACRO>
<NAME>g_array_insert_val</NAME>
#define g_array_insert_val(a,i,v) g_array_insert_vals (a, i, &v, 1)
</MACRO>
<MACRO>
<NAME>g_array_index</NAME>
#define g_array_index(a,t,i)      (((t*) (a)->data) [(i)])
</MACRO>
<FUNCTION>
<NAME>g_array_new</NAME>
<RETURNS>GArray *</RETURNS>
gboolean	    zero_terminated,gboolean	    clear,guint	    element_size
</FUNCTION>
<FUNCTION>
<NAME>g_array_sized_new</NAME>
<RETURNS>GArray *</RETURNS>
gboolean	    zero_terminated,gboolean	    clear,guint	    element_size,guint            reserved_size
</FUNCTION>
<FUNCTION>
<NAME>g_array_free</NAME>
<RETURNS>gchar *</RETURNS>
GArray	   *array,gboolean	    free_segment
</FUNCTION>
<FUNCTION>
<NAME>g_array_append_vals</NAME>
<RETURNS>GArray *</RETURNS>
GArray	   *array,gconstpointer    data,guint	    len
</FUNCTION>
<FUNCTION>
<NAME>g_array_prepend_vals</NAME>
<RETURNS>GArray *</RETURNS>
GArray	   *array,gconstpointer    data,guint	    len
</FUNCTION>
<FUNCTION>
<NAME>g_array_insert_vals</NAME>
<RETURNS>GArray *</RETURNS>
GArray          *array,guint            index,gconstpointer    data,guint            len
</FUNCTION>
<FUNCTION>
<NAME>g_array_set_size</NAME>
<RETURNS>GArray *</RETURNS>
GArray	   *array,guint	    length
</FUNCTION>
<FUNCTION>
<NAME>g_array_remove_index</NAME>
<RETURNS>GArray *</RETURNS>
GArray	   *array,guint	    index
</FUNCTION>
<FUNCTION>
<NAME>g_array_remove_index_fast</NAME>
<RETURNS>GArray *</RETURNS>
GArray	   *array,guint	    index
</FUNCTION>
<MACRO>
<NAME>g_ptr_array_index</NAME>
#define	    g_ptr_array_index(array,index) (array->pdata)[index]
</MACRO>
<FUNCTION>
<NAME>g_ptr_array_new</NAME>
<RETURNS>GPtrArray *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_sized_new</NAME>
<RETURNS>GPtrArray *</RETURNS>
guint        reserved_size
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_free</NAME>
<RETURNS>gpointer *</RETURNS>
GPtrArray	*array,gboolean	 free_seg
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_set_size</NAME>
<RETURNS>void 	</RETURNS>
GPtrArray	*array,gint	 length
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove_index</NAME>
<RETURNS>gpointer  </RETURNS>
GPtrArray	*array,guint	 index
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove_index_fast</NAME>
<RETURNS>gpointer  </RETURNS>
GPtrArray	*array,guint	 index
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove</NAME>
<RETURNS>gboolean  </RETURNS>
GPtrArray	*array,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_remove_fast</NAME>
<RETURNS>gboolean  </RETURNS>
GPtrArray	*array,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_ptr_array_add</NAME>
<RETURNS>void 	</RETURNS>
GPtrArray	*array,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_new</NAME>
<RETURNS>GByteArray *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_sized_new</NAME>
<RETURNS>GByteArray *</RETURNS>
guint        reserved_size
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_free</NAME>
<RETURNS>guint8 *</RETURNS>
GByteArray	 *array,gboolean	  free_segment
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_append</NAME>
<RETURNS>GByteArray *</RETURNS>
GByteArray	 *array,const guint8 *data,guint	  len
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_prepend</NAME>
<RETURNS>GByteArray *</RETURNS>
GByteArray	 *array,const guint8 *data,guint	  len
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_set_size</NAME>
<RETURNS>GByteArray *</RETURNS>
GByteArray	 *array,guint	  length
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_remove_index</NAME>
<RETURNS>GByteArray *</RETURNS>
GByteArray	 *array,guint	  index
</FUNCTION>
<FUNCTION>
<NAME>g_byte_array_remove_index_fast</NAME>
<RETURNS>GByteArray *</RETURNS>
GByteArray	 *array,guint	  index
</FUNCTION>
<FUNCTION>
<NAME>g_str_equal</NAME>
<RETURNS>gboolean  </RETURNS>
gconstpointer   v,gconstpointer   v2
</FUNCTION>
<FUNCTION>
<NAME>g_str_hash</NAME>
<RETURNS>guint 	</RETURNS>
gconstpointer   v
</FUNCTION>
<FUNCTION>
<NAME>g_int_equal</NAME>
<RETURNS>gint 	</RETURNS>
gconstpointer   v,gconstpointer   v2
</FUNCTION>
<FUNCTION>
<NAME>g_int_hash</NAME>
<RETURNS>guint 	</RETURNS>
gconstpointer   v
</FUNCTION>
<FUNCTION>
<NAME>g_direct_hash</NAME>
<RETURNS>guint  </RETURNS>
gconstpointer v
</FUNCTION>
<FUNCTION>
<NAME>g_direct_equal</NAME>
<RETURNS>gint  </RETURNS>
gconstpointer v,gconstpointer v2
</FUNCTION>
<FUNCTION>
<NAME>g_quark_try_string</NAME>
<RETURNS>GQuark 	</RETURNS>
const gchar	*string
</FUNCTION>
<FUNCTION>
<NAME>g_quark_from_static_string</NAME>
<RETURNS>GQuark 	</RETURNS>
const gchar	*string
</FUNCTION>
<FUNCTION>
<NAME>g_quark_from_string</NAME>
<RETURNS>GQuark 	</RETURNS>
const gchar	*string
</FUNCTION>
<FUNCTION>
<NAME>g_quark_to_string</NAME>
<RETURNS>gchar *</RETURNS>
GQuark		 quark
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_init</NAME>
<RETURNS>void 	</RETURNS>
GData		 **datalist
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_clear</NAME>
<RETURNS>void 	</RETURNS>
GData		 **datalist
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
GData		 **datalist,GQuark	   key_id
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_set_data_full</NAME>
<RETURNS>void 	</RETURNS>
GData		 **datalist,GQuark	   key_id,gpointer	   data,GDestroyNotify   destroy_func
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_id_remove_no_notify</NAME>
<RETURNS>gpointer  </RETURNS>
GData		 **datalist,GQuark	   key_id
</FUNCTION>
<FUNCTION>
<NAME>g_datalist_foreach</NAME>
<RETURNS>void 	</RETURNS>
GData		 **datalist,GDataForeachFunc func,gpointer	   user_data
</FUNCTION>
<MACRO>
<NAME>g_datalist_id_set_data</NAME>
#define	  g_datalist_id_set_data(dl, q, d)	\
     g_datalist_id_set_data_full ((dl), (q), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_datalist_id_remove_data</NAME>
#define	  g_datalist_id_remove_data(dl, q)	\
     g_datalist_id_set_data ((dl), (q), NULL)
</MACRO>
<MACRO>
<NAME>g_datalist_get_data</NAME>
#define	  g_datalist_get_data(dl, k)		\
     (g_datalist_id_get_data ((dl), g_quark_try_string (k)))
</MACRO>
<MACRO>
<NAME>g_datalist_set_data_full</NAME>
#define	  g_datalist_set_data_full(dl, k, d, f)	\
     g_datalist_id_set_data_full ((dl), g_quark_from_string (k), (d), (f))
</MACRO>
<MACRO>
<NAME>g_datalist_remove_no_notify</NAME>
#define	  g_datalist_remove_no_notify(dl, k)	\
     g_datalist_id_remove_no_notify ((dl), g_quark_try_string (k))
</MACRO>
<MACRO>
<NAME>g_datalist_set_data</NAME>
#define	  g_datalist_set_data(dl, k, d)		\
     g_datalist_set_data_full ((dl), (k), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_datalist_remove_data</NAME>
#define	  g_datalist_remove_data(dl, k)		\
     g_datalist_id_set_data ((dl), g_quark_try_string (k), NULL)
</MACRO>
<FUNCTION>
<NAME>g_dataset_destroy</NAME>
<RETURNS>void 	</RETURNS>
gconstpointer	  dataset_location
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_id_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
gconstpointer	  dataset_location,GQuark		  key_id
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_id_set_data_full</NAME>
<RETURNS>void 	</RETURNS>
gconstpointer	  dataset_location,GQuark		  key_id,gpointer	  data,GDestroyNotify	  destroy_func
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_id_remove_no_notify</NAME>
<RETURNS>gpointer  </RETURNS>
gconstpointer	  dataset_location,GQuark		  key_id
</FUNCTION>
<FUNCTION>
<NAME>g_dataset_foreach</NAME>
<RETURNS>void 	</RETURNS>
gconstpointer	  dataset_location,GDataForeachFunc func,gpointer	  user_data
</FUNCTION>
<MACRO>
<NAME>g_dataset_id_set_data</NAME>
#define	  g_dataset_id_set_data(l, k, d)	\
     g_dataset_id_set_data_full ((l), (k), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_dataset_id_remove_data</NAME>
#define	  g_dataset_id_remove_data(l, k)	\
     g_dataset_id_set_data ((l), (k), NULL)
</MACRO>
<MACRO>
<NAME>g_dataset_get_data</NAME>
#define	  g_dataset_get_data(l, k)		\
     (g_dataset_id_get_data ((l), g_quark_try_string (k)))
</MACRO>
<MACRO>
<NAME>g_dataset_set_data_full</NAME>
#define	  g_dataset_set_data_full(l, k, d, f)	\
     g_dataset_id_set_data_full ((l), g_quark_from_string (k), (d), (f))
</MACRO>
<MACRO>
<NAME>g_dataset_remove_no_notify</NAME>
#define	  g_dataset_remove_no_notify(l, k)	\
     g_dataset_id_remove_no_notify ((l), g_quark_try_string (k))
</MACRO>
<MACRO>
<NAME>g_dataset_set_data</NAME>
#define	  g_dataset_set_data(l, k, d)		\
     g_dataset_set_data_full ((l), (k), (d), NULL)
</MACRO>
<MACRO>
<NAME>g_dataset_remove_data</NAME>
#define	  g_dataset_remove_data(l, k)		\
     g_dataset_id_set_data ((l), g_quark_try_string (k), NULL)
</MACRO>
<MACRO>
<NAME>G_CSET_A_2_Z</NAME>
#define G_CSET_A_2_Z	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
</MACRO>
<MACRO>
<NAME>G_CSET_a_2_z</NAME>
#define G_CSET_a_2_z	"abcdefghijklmnopqrstuvwxyz"
</MACRO>
<MACRO>
<NAME>G_CSET_DIGITS</NAME>
#define G_CSET_DIGITS	"0123456789"
</MACRO>
<MACRO>
<NAME>G_CSET_LATINC</NAME>
#define G_CSET_LATINC	"\300\301\302\303\304\305\306"\
			"\307\310\311\312\313\314\315\316\317\320"\
			"\321\322\323\324\325\326"\
			"\330\331\332\333\334\335\336"
</MACRO>
<MACRO>
<NAME>G_CSET_LATINS</NAME>
#define G_CSET_LATINS	"\337\340\341\342\343\344\345\346"\
			"\347\350\351\352\353\354\355\356\357\360"\
			"\361\362\363\364\365\366"\
			"\370\371\372\373\374\375\376\377"
</MACRO>
<ENUM>
<NAME>GErrorType</NAME>
typedef enum
{
  G_ERR_UNKNOWN,
  G_ERR_UNEXP_EOF,
  G_ERR_UNEXP_EOF_IN_STRING,
  G_ERR_UNEXP_EOF_IN_COMMENT,
  G_ERR_NON_DIGIT_IN_CONST,
  G_ERR_DIGIT_RADIX,
  G_ERR_FLOAT_RADIX,
  G_ERR_FLOAT_MALFORMED
} GErrorType;
</ENUM>
<ENUM>
<NAME>GTokenType</NAME>
typedef enum
{
  G_TOKEN_EOF			=   0,
  
  G_TOKEN_LEFT_PAREN		= '(',
  G_TOKEN_RIGHT_PAREN		= ')',
  G_TOKEN_LEFT_CURLY		= '{',
  G_TOKEN_RIGHT_CURLY		= '}',
  G_TOKEN_LEFT_BRACE		= '[',
  G_TOKEN_RIGHT_BRACE		= ']',
  G_TOKEN_EQUAL_SIGN		= '=',
  G_TOKEN_COMMA			= ',',
  
  G_TOKEN_NONE			= 256,
  
  G_TOKEN_ERROR,
  
  G_TOKEN_CHAR,
  G_TOKEN_BINARY,
  G_TOKEN_OCTAL,
  G_TOKEN_INT,
  G_TOKEN_HEX,
  G_TOKEN_FLOAT,
  G_TOKEN_STRING,
  
  G_TOKEN_SYMBOL,
  G_TOKEN_IDENTIFIER,
  G_TOKEN_IDENTIFIER_NULL,
  
  G_TOKEN_COMMENT_SINGLE,
  G_TOKEN_COMMENT_MULTI,
  G_TOKEN_LAST
} GTokenType;
</ENUM>
<UNION>
<NAME>GTokenValue</NAME>
union GTokenValue
{
  gpointer	v_symbol;
  gchar		*v_identifier;
  gulong	v_binary;
  gulong	v_octal;
  gulong	v_int;
  gdouble	v_float;
  gulong	v_hex;
  gchar		*v_string;
  gchar		*v_comment;
  guchar	v_char;
  guint		v_error;
};
</UNION>
<STRUCT>
<NAME>GScannerConfig</NAME>
struct GScannerConfig
{
  /* Character sets
   */
  gchar		*cset_skip_characters;		/* default: " \t\n" */
  gchar		*cset_identifier_first;
  gchar		*cset_identifier_nth;
  gchar		*cpair_comment_single;		/* default: "#\n" */
  
  /* Should symbol lookup work case sensitive?
   */
  guint		case_sensitive : 1;
  
  /* Boolean values to be adjusted "on the fly"
   * to configure scanning behaviour.
   */
  guint		skip_comment_multi : 1;		/* C like comment */
  guint		skip_comment_single : 1;	/* single line comment */
  guint		scan_comment_multi : 1;		/* scan multi line comments? */
  guint		scan_identifier : 1;
  guint		scan_identifier_1char : 1;
  guint		scan_identifier_NULL : 1;
  guint		scan_symbols : 1;
  guint		scan_binary : 1;
  guint		scan_octal : 1;
  guint		scan_float : 1;
  guint		scan_hex : 1;			/* `0x0ff0' */
  guint		scan_hex_dollar : 1;		/* `$0ff0' */
  guint		scan_string_sq : 1;		/* string: 'anything' */
  guint		scan_string_dq : 1;		/* string: "\\-escapes!\n" */
  guint		numbers_2_int : 1;		/* bin, octal, hex => int */
  guint		int_2_float : 1;		/* int => G_TOKEN_FLOAT? */
  guint		identifier_2_string : 1;
  guint		char_2_token : 1;		/* return G_TOKEN_CHAR? */
  guint		symbol_2_token : 1;
  guint		scope_0_fallback : 1;		/* try scope 0 on lookups? */
};
</STRUCT>
<STRUCT>
<NAME>GScanner</NAME>
struct GScanner
{
  /* unused fields */
  gpointer		user_data;
  guint			max_parse_errors;
  
  /* g_scanner_error() increments this field */
  guint			parse_errors;
  
  /* name of input stream, featured by the default message handler */
  const gchar		*input_name;
  
  /* data pointer for derived structures */
  gpointer		derived_data;
  
  /* link into the scanner configuration */
  GScannerConfig	*config;
  
  /* fields filled in after g_scanner_get_next_token() */
  GTokenType		token;
  GTokenValue		value;
  guint			line;
  guint			position;
  
  /* fields filled in after g_scanner_peek_next_token() */
  GTokenType		next_token;
  GTokenValue		next_value;
  guint			next_line;
  guint			next_position;
  
  /* to be considered private */
  GHashTable		*symbol_table;
  gint			input_fd;
  const gchar		*text;
  const gchar		*text_end;
  gchar			*buffer;
  guint			scope_id;
  
  /* handler function for _warn and _error */
  GScannerMsgFunc	msg_handler;
};
</STRUCT>
<FUNCTION>
<NAME>g_scanner_new</NAME>
<RETURNS>GScanner *</RETURNS>
GScannerConfig *config_templ
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_destroy</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_input_file</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,gint		input_fd
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_sync_file_offset</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_input_text</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,const	gchar	*text,guint		text_len
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_get_next_token</NAME>
<RETURNS>GTokenType 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_peek_next_token</NAME>
<RETURNS>GTokenType 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_token</NAME>
<RETURNS>GTokenType 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_value</NAME>
<RETURNS>GTokenValue 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_line</NAME>
<RETURNS>guint 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_cur_position</NAME>
<RETURNS>guint 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_eof</NAME>
<RETURNS>gboolean 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_set_scope</NAME>
<RETURNS>guint 	</RETURNS>
GScanner	*scanner,guint		 scope_id
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_add_symbol</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,guint		 scope_id,const gchar	*symbol,gpointer	value
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_remove_symbol</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,guint		 scope_id,const gchar	*symbol
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_lookup_symbol</NAME>
<RETURNS>gpointer 	</RETURNS>
GScanner	*scanner,guint		 scope_id,const gchar	*symbol
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_scope_foreach_symbol</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,guint		 scope_id,GHFunc		 func,gpointer	 user_data
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_lookup_symbol</NAME>
<RETURNS>gpointer 	</RETURNS>
GScanner	*scanner,const gchar	*symbol
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_unexp_token</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,GTokenType	expected_token,const gchar	*identifier_spec,const gchar	*symbol_spec,const gchar	*symbol_name,const gchar	*message,gint		 is_error
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_error</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,const gchar	*format,...
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_warn</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner,const gchar	*format,...
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_stat_mode</NAME>
<RETURNS>gint 	</RETURNS>
const gchar	*filename
</FUNCTION>
<MACRO>
<NAME>g_scanner_add_symbol</NAME>
#define		g_scanner_add_symbol( scanner, symbol, value )	G_STMT_START { \
  g_scanner_scope_add_symbol ((scanner), 0, (symbol), (value)); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>g_scanner_remove_symbol</NAME>
#define		g_scanner_remove_symbol( scanner, symbol )	G_STMT_START { \
  g_scanner_scope_remove_symbol ((scanner), 0, (symbol)); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>g_scanner_foreach_symbol</NAME>
#define		g_scanner_foreach_symbol( scanner, func, data )	G_STMT_START { \
  g_scanner_scope_foreach_symbol ((scanner), 0, (func), (data)); \
} G_STMT_END
</MACRO>
<FUNCTION>
<NAME>g_scanner_freeze_symbol_table</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<FUNCTION>
<NAME>g_scanner_thaw_symbol_table</NAME>
<RETURNS>void 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<STRUCT>
<NAME>GCompletion</NAME>
struct GCompletion
{
  GList* items;
  GCompletionFunc func;
  
  gchar* prefix;
  GList* cache;
};
</STRUCT>
<FUNCTION>
<NAME>g_completion_new</NAME>
<RETURNS>GCompletion *</RETURNS>
GCompletionFunc func
</FUNCTION>
<FUNCTION>
<NAME>g_completion_add_items</NAME>
<RETURNS>void 	</RETURNS>
GCompletion*	cmp,GList*		items
</FUNCTION>
<FUNCTION>
<NAME>g_completion_remove_items</NAME>
<RETURNS>void 	</RETURNS>
GCompletion*	cmp,GList*		items
</FUNCTION>
<FUNCTION>
<NAME>g_completion_clear_items</NAME>
<RETURNS>void 	</RETURNS>
GCompletion*	cmp
</FUNCTION>
<FUNCTION>
<NAME>g_completion_complete</NAME>
<RETURNS>GList *</RETURNS>
GCompletion*	cmp,gchar*		prefix,gchar**		new_prefix
</FUNCTION>
<FUNCTION>
<NAME>g_completion_free</NAME>
<RETURNS>void 	</RETURNS>
GCompletion*	cmp
</FUNCTION>
<TYPEDEF>
<NAME>GDateYear</NAME>
typedef guint16 GDateYear;
</TYPEDEF>
<TYPEDEF>
<NAME>GDateDay</NAME>
typedef guint8  GDateDay;   /* day of the month */
</TYPEDEF>
<STRUCT>
<NAME>GDate</NAME>
</STRUCT>
<ENUM>
<NAME>GDateDMY</NAME>
typedef enum
{
  G_DATE_DAY   = 0,
  G_DATE_MONTH = 1,
  G_DATE_YEAR  = 2
} GDateDMY;
</ENUM>
<ENUM>
<NAME>GDateWeekday</NAME>
typedef enum
{
  G_DATE_BAD_WEEKDAY  = 0,
  G_DATE_MONDAY       = 1,
  G_DATE_TUESDAY      = 2,
  G_DATE_WEDNESDAY    = 3,
  G_DATE_THURSDAY     = 4,
  G_DATE_FRIDAY       = 5,
  G_DATE_SATURDAY     = 6,
  G_DATE_SUNDAY       = 7
} GDateWeekday;
</ENUM>
<ENUM>
<NAME>GDateMonth</NAME>
typedef enum
{
  G_DATE_BAD_MONTH = 0,
  G_DATE_JANUARY   = 1,
  G_DATE_FEBRUARY  = 2,
  G_DATE_MARCH     = 3,
  G_DATE_APRIL     = 4,
  G_DATE_MAY       = 5,
  G_DATE_JUNE      = 6,
  G_DATE_JULY      = 7,
  G_DATE_AUGUST    = 8,
  G_DATE_SEPTEMBER = 9,
  G_DATE_OCTOBER   = 10,
  G_DATE_NOVEMBER  = 11,
  G_DATE_DECEMBER  = 12
} GDateMonth;
</ENUM>
<MACRO>
<NAME>G_DATE_BAD_JULIAN</NAME>
#define G_DATE_BAD_JULIAN 0U
</MACRO>
<MACRO>
<NAME>G_DATE_BAD_DAY</NAME>
#define G_DATE_BAD_DAY    0U
</MACRO>
<MACRO>
<NAME>G_DATE_BAD_YEAR</NAME>
#define G_DATE_BAD_YEAR   0U
</MACRO>
<STRUCT>
<NAME>GDate</NAME>
struct GDate
{ 
  guint julian_days : 32; /* julian days representation - we use a
                           *  bitfield hoping that 64 bit platforms
                           *  will pack this whole struct in one big
                           *  int 
                           */

  guint julian : 1;    /* julian is valid */
  guint dmy    : 1;    /* dmy is valid */

  /* DMY representation */
  guint day    : 6;  
  guint month  : 4; 
  guint year   : 16; 
};
</STRUCT>
<FUNCTION>
<NAME>g_date_new</NAME>
<RETURNS>GDate *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_date_new_dmy</NAME>
<RETURNS>GDate *</RETURNS>
GDateDay     day,GDateMonth   month,GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_new_julian</NAME>
<RETURNS>GDate *</RETURNS>
guint32      julian_day
</FUNCTION>
<FUNCTION>
<NAME>g_date_free</NAME>
<RETURNS>void  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid</NAME>
<RETURNS>gboolean  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_day</NAME>
<RETURNS>gboolean  </RETURNS>
GDateDay     day
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_month</NAME>
<RETURNS>gboolean  </RETURNS>
GDateMonth   month
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_year</NAME>
<RETURNS>gboolean  </RETURNS>
GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_weekday</NAME>
<RETURNS>gboolean  </RETURNS>
GDateWeekday weekday
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_julian</NAME>
<RETURNS>gboolean  </RETURNS>
guint32      julian_date
</FUNCTION>
<FUNCTION>
<NAME>g_date_valid_dmy</NAME>
<RETURNS>gboolean  </RETURNS>
GDateDay     day,GDateMonth   month,GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_weekday</NAME>
<RETURNS>GDateWeekday  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_month</NAME>
<RETURNS>GDateMonth  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_year</NAME>
<RETURNS>GDateYear  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_day</NAME>
<RETURNS>GDateDay  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_julian</NAME>
<RETURNS>guint32  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_day_of_year</NAME>
<RETURNS>guint  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_monday_week_of_year</NAME>
<RETURNS>guint  </RETURNS>
GDate      *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_sunday_week_of_year</NAME>
<RETURNS>guint  </RETURNS>
GDate      *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_clear</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint        n_dates
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_parse</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,const gchar *str
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_time</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,GTime        time
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_month</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,GDateMonth   month
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_day</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,GDateDay     day
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_year</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_dmy</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,GDateDay     day,GDateMonth   month,GDateYear    y
</FUNCTION>
<FUNCTION>
<NAME>g_date_set_julian</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint32      julian_date
</FUNCTION>
<FUNCTION>
<NAME>g_date_is_first_of_month</NAME>
<RETURNS>gboolean  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_is_last_of_month</NAME>
<RETURNS>gboolean  </RETURNS>
GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_date_add_days</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint        n_days
</FUNCTION>
<FUNCTION>
<NAME>g_date_subtract_days</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint        n_days
</FUNCTION>
<FUNCTION>
<NAME>g_date_add_months</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint        n_months
</FUNCTION>
<FUNCTION>
<NAME>g_date_subtract_months</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint        n_months
</FUNCTION>
<FUNCTION>
<NAME>g_date_add_years</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint        n_years
</FUNCTION>
<FUNCTION>
<NAME>g_date_subtract_years</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,guint        n_years
</FUNCTION>
<FUNCTION>
<NAME>g_date_is_leap_year</NAME>
<RETURNS>gboolean  </RETURNS>
GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_days_in_month</NAME>
<RETURNS>guint8  </RETURNS>
GDateMonth   month,GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_monday_weeks_in_year</NAME>
<RETURNS>guint8  </RETURNS>
GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_sunday_weeks_in_year</NAME>
<RETURNS>guint8  </RETURNS>
GDateYear    year
</FUNCTION>
<FUNCTION>
<NAME>g_date_compare</NAME>
<RETURNS>gint  </RETURNS>
GDate       *lhs,GDate       *rhs
</FUNCTION>
<FUNCTION>
<NAME>g_date_to_struct_tm</NAME>
<RETURNS>void  </RETURNS>
GDate       *date,struct tm   *tm
</FUNCTION>
<FUNCTION>
<NAME>g_date_strftime</NAME>
<RETURNS>gsize  </RETURNS>
gchar       *s,gsize        slen,const gchar *format,GDate       *date
</FUNCTION>
<FUNCTION>
<NAME>g_relation_new</NAME>
<RETURNS>GRelation *</RETURNS>
gint	    fields
</FUNCTION>
<FUNCTION>
<NAME>g_relation_destroy</NAME>
<RETURNS>void 	</RETURNS>
GRelation   *relation
</FUNCTION>
<FUNCTION>
<NAME>g_relation_index</NAME>
<RETURNS>void 	</RETURNS>
GRelation   *relation,gint	    field,GHashFunc    hash_func,GCompareFunc key_compare_func
</FUNCTION>
<FUNCTION>
<NAME>g_relation_insert</NAME>
<RETURNS>void 	</RETURNS>
GRelation   *relation,...
</FUNCTION>
<FUNCTION>
<NAME>g_relation_delete</NAME>
<RETURNS>gint 	</RETURNS>
GRelation   *relation,gconstpointer  key,gint	    field
</FUNCTION>
<FUNCTION>
<NAME>g_relation_select</NAME>
<RETURNS>GTuples *</RETURNS>
GRelation   *relation,gconstpointer  key,gint	    field
</FUNCTION>
<FUNCTION>
<NAME>g_relation_count</NAME>
<RETURNS>gint 	</RETURNS>
GRelation   *relation,gconstpointer  key,gint	    field
</FUNCTION>
<FUNCTION>
<NAME>g_relation_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GRelation   *relation,...
</FUNCTION>
<FUNCTION>
<NAME>g_relation_print</NAME>
<RETURNS>void 	</RETURNS>
GRelation   *relation
</FUNCTION>
<FUNCTION>
<NAME>g_tuples_destroy</NAME>
<RETURNS>void 	</RETURNS>
GTuples	   *tuples
</FUNCTION>
<FUNCTION>
<NAME>g_tuples_index</NAME>
<RETURNS>gpointer  </RETURNS>
GTuples	   *tuples,gint	    index,gint	    field
</FUNCTION>
<FUNCTION>
<NAME>g_rand_new_with_seed</NAME>
<RETURNS>GRand *</RETURNS>
guint32     seed
</FUNCTION>
<FUNCTION>
<NAME>g_rand_new</NAME>
<RETURNS>GRand *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_rand_free</NAME>
<RETURNS>void  </RETURNS>
GRand      *rand
</FUNCTION>
<FUNCTION>
<NAME>g_rand_set_seed</NAME>
<RETURNS>void  </RETURNS>
GRand      *rand,guint32     seed
</FUNCTION>
<FUNCTION>
<NAME>g_rand_int</NAME>
<RETURNS>guint32  </RETURNS>
GRand      *rand
</FUNCTION>
<FUNCTION>
<NAME>g_rand_int_range</NAME>
<RETURNS>gint32  </RETURNS>
GRand      *rand,gint32      min,gint32      max
</FUNCTION>
<FUNCTION>
<NAME>g_rand_double</NAME>
<RETURNS>gdouble  </RETURNS>
GRand      *rand
</FUNCTION>
<FUNCTION>
<NAME>g_rand_double_range</NAME>
<RETURNS>gdouble  </RETURNS>
GRand      *rand,gdouble     min,gdouble     max
</FUNCTION>
<FUNCTION>
<NAME>g_random_set_seed</NAME>
<RETURNS>void  </RETURNS>
guint32     seed
</FUNCTION>
<FUNCTION>
<NAME>g_random_int</NAME>
<RETURNS>guint32  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_random_int_range</NAME>
<RETURNS>gint32  </RETURNS>
gint32      min,gint32      max
</FUNCTION>
<FUNCTION>
<NAME>g_random_double</NAME>
<RETURNS>gdouble  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_random_double_range</NAME>
<RETURNS>gdouble  </RETURNS>
gdouble     min,gdouble     max
</FUNCTION>
<FUNCTION>
<NAME>g_spaced_primes_closest</NAME>
<RETURNS>guint 	</RETURNS>
guint num
</FUNCTION>
<STRUCT>
<NAME>GIOFuncs</NAME>
</STRUCT>
<ENUM>
<NAME>GIOError</NAME>
typedef enum
{
  G_IO_ERROR_NONE,
  G_IO_ERROR_AGAIN,
  G_IO_ERROR_INVAL,
  G_IO_ERROR_UNKNOWN
} GIOError;
</ENUM>
<ENUM>
<NAME>GSeekType</NAME>
typedef enum
{
  G_SEEK_CUR,
  G_SEEK_SET,
  G_SEEK_END
} GSeekType;
</ENUM>
<ENUM>
<NAME>GIOCondition</NAME>
typedef enum
{
  G_IO_IN	GLIB_SYSDEF_POLLIN,
  G_IO_OUT	GLIB_SYSDEF_POLLOUT,
  G_IO_PRI	GLIB_SYSDEF_POLLPRI,
  G_IO_ERR	GLIB_SYSDEF_POLLERR,
  G_IO_HUP	GLIB_SYSDEF_POLLHUP,
  G_IO_NVAL	GLIB_SYSDEF_POLLNVAL
} GIOCondition;
</ENUM>
<STRUCT>
<NAME>GIOChannel</NAME>
struct GIOChannel
{
  guint channel_flags;
  guint ref_count;
  GIOFuncs *funcs;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GIOFunc</NAME>
<RETURNS>gboolean </RETURNS>
GIOChannel   *source,
			     GIOCondition  condition,
			     gpointer      data
</USER_FUNCTION>
<STRUCT>
<NAME>GIOFuncs</NAME>
struct GIOFuncs
{
  GIOError (*io_read)   (GIOChannel 	*channel, 
		         gchar      	*buf, 
		         guint      	 count,
			 guint      	*bytes_read);
  GIOError (*io_write)  (GIOChannel 	*channel, 
		 	 gchar      	*buf, 
			 guint      	 count,
			 guint      	*bytes_written);
  GIOError (*io_seek)   (GIOChannel   	*channel, 
		 	 gint       	 offset, 
		  	 GSeekType  	 type);
  void (*io_close)      (GIOChannel	*channel);
  guint (*io_add_watch) (GIOChannel     *channel,
			 gint            priority,
			 GIOCondition    condition,
			 GIOFunc         func,
			 gpointer        user_data,
			 GDestroyNotify  notify);
  void (*io_free)       (GIOChannel	*channel);
};
</STRUCT>
<FUNCTION>
<NAME>g_io_channel_init</NAME>
<RETURNS>void  </RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_ref</NAME>
<RETURNS>void  </RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_unref</NAME>
<RETURNS>void  </RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_read</NAME>
<RETURNS>GIOError  </RETURNS>
GIOChannel    *channel,gchar         *buf,guint          count,guint         *bytes_read
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_write</NAME>
<RETURNS>GIOError  </RETURNS>
GIOChannel    *channel,gchar         *buf,guint          count,guint         *bytes_written
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_seek</NAME>
<RETURNS>GIOError  </RETURNS>
GIOChannel    *channel,gint           offset,GSeekType      type
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_close</NAME>
<RETURNS>void  </RETURNS>
GIOChannel    *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_add_watch_full</NAME>
<RETURNS>guint  </RETURNS>
GIOChannel    *channel,gint           priority,GIOCondition   condition,GIOFunc        func,gpointer       user_data,GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>g_io_add_watch</NAME>
<RETURNS>guint  </RETURNS>
GIOChannel    *channel,GIOCondition   condition,GIOFunc        func,gpointer       user_data
</FUNCTION>
<STRUCT>
<NAME>GTimeVal</NAME>
</STRUCT>
<STRUCT>
<NAME>GSourceFuncs</NAME>
</STRUCT>
<STRUCT>
<NAME>GMainLoop</NAME>
</STRUCT>
<STRUCT>
<NAME>GTimeVal</NAME>
struct GTimeVal
{
  glong tv_sec;
  glong tv_usec;
};
</STRUCT>
<STRUCT>
<NAME>GSourceFuncs</NAME>
struct GSourceFuncs
{
  gboolean (*prepare)  (gpointer  source_data, 
			GTimeVal *current_time,
			gint     *timeout,
			gpointer  user_data);
  gboolean (*check)    (gpointer  source_data,
			GTimeVal *current_time,
			gpointer  user_data);
  gboolean (*dispatch) (gpointer  source_data, 
			GTimeVal *dispatch_time,
			gpointer  user_data);
  GDestroyNotify destroy;
};
</STRUCT>
<MACRO>
<NAME>G_PRIORITY_HIGH</NAME>
#define G_PRIORITY_HIGH            -100
</MACRO>
<MACRO>
<NAME>G_PRIORITY_DEFAULT</NAME>
#define G_PRIORITY_DEFAULT          0
</MACRO>
<MACRO>
<NAME>G_PRIORITY_HIGH_IDLE</NAME>
#define G_PRIORITY_HIGH_IDLE        100
</MACRO>
<MACRO>
<NAME>G_PRIORITY_DEFAULT_IDLE</NAME>
#define G_PRIORITY_DEFAULT_IDLE     200
</MACRO>
<MACRO>
<NAME>G_PRIORITY_LOW</NAME>
#define G_PRIORITY_LOW	            300
</MACRO>
<USER_FUNCTION>
<NAME>GSourceFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer data
</USER_FUNCTION>
<FUNCTION>
<NAME>g_source_add</NAME>
<RETURNS>guint  </RETURNS>
gint           priority,gboolean       can_recurse,GSourceFuncs  *funcs,gpointer       source_data,gpointer       user_data,GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove</NAME>
<RETURNS>gboolean  </RETURNS>
guint          tag
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_by_user_data</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer       user_data
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_by_source_data</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer       source_data
</FUNCTION>
<FUNCTION>
<NAME>g_source_remove_by_funcs_user_data</NAME>
<RETURNS>gboolean  </RETURNS>
GSourceFuncs  *funcs,gpointer       user_data
</FUNCTION>
<FUNCTION>
<NAME>g_get_current_time</NAME>
<RETURNS>void  </RETURNS>
GTimeVal	*result
</FUNCTION>
<FUNCTION>
<NAME>g_main_new</NAME>
<RETURNS>GMainLoop *</RETURNS>
gboolean	 is_running
</FUNCTION>
<FUNCTION>
<NAME>g_main_run</NAME>
<RETURNS>void 	</RETURNS>
GMainLoop	*loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_quit</NAME>
<RETURNS>void 	</RETURNS>
GMainLoop	*loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_destroy</NAME>
<RETURNS>void 	</RETURNS>
GMainLoop	*loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_is_running</NAME>
<RETURNS>gboolean 	</RETURNS>
GMainLoop	*loop
</FUNCTION>
<FUNCTION>
<NAME>g_main_iteration</NAME>
<RETURNS>gboolean 	</RETURNS>
gboolean	may_block
</FUNCTION>
<FUNCTION>
<NAME>g_main_pending</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_add_full</NAME>
<RETURNS>guint 	</RETURNS>
gint           priority,guint          interval,GSourceFunc    function,gpointer       data,GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>g_timeout_add</NAME>
<RETURNS>guint 	</RETURNS>
guint          interval,GSourceFunc    function,gpointer       data
</FUNCTION>
<FUNCTION>
<NAME>g_idle_add</NAME>
<RETURNS>guint 	</RETURNS>
GSourceFunc	function,gpointer	data
</FUNCTION>
<FUNCTION>
<NAME>g_idle_add_full</NAME>
<RETURNS>guint 	</RETURNS>
gint   	priority,GSourceFunc	function,gpointer	data,GDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>g_idle_remove_by_data</NAME>
<RETURNS>gboolean 	</RETURNS>
gpointer	data
</FUNCTION>
<STRUCT>
<NAME>GPollFD</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GPollFunc</NAME>
<RETURNS>gint </RETURNS>
GPollFD *ufds,
				 guint	  nfsd,
				 gint     timeout
</USER_FUNCTION>
<STRUCT>
<NAME>GPollFD</NAME>
struct GPollFD
{
  gint		fd;
  gushort 	events;
  gushort 	revents;
};
</STRUCT>
<FUNCTION>
<NAME>g_main_add_poll</NAME>
<RETURNS>void  </RETURNS>
GPollFD    *fd,gint        priority
</FUNCTION>
<FUNCTION>
<NAME>g_main_remove_poll</NAME>
<RETURNS>void  </RETURNS>
GPollFD    *fd
</FUNCTION>
<FUNCTION>
<NAME>g_main_set_poll_func</NAME>
<RETURNS>void  </RETURNS>
GPollFunc   func
</FUNCTION>
<FUNCTION>
<NAME>g_main_win32_get_poll_func</NAME>
<RETURNS>GPollFunc  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_unix_new</NAME>
<RETURNS>GIOChannel *</RETURNS>
int         fd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_unix_get_fd</NAME>
<RETURNS>gint  </RETURNS>
GIOChannel *channel
</FUNCTION>
<MACRO>
<NAME>G_WIN32_MSG_HANDLE</NAME>
#define G_WIN32_MSG_HANDLE 19981206
</MACRO>
<FUNCTION>
<NAME>g_io_channel_win32_make_pollfd</NAME>
<RETURNS>void  </RETURNS>
GIOChannel   *channel,GIOCondition  condition,GPollFD      *fd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_poll</NAME>
<RETURNS>gint  </RETURNS>
GPollFD    *fds,gint        n_fds,gint        timeout
</FUNCTION>
<FUNCTION>
<NAME>g_main_poll_win32_msg_add</NAME>
<RETURNS>void  </RETURNS>
gint        priority,GPollFD    *fd,guint       hwnd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_new_messages</NAME>
<RETURNS>GIOChannel  *</RETURNS>
guint hwnd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_new_fd</NAME>
<RETURNS>GIOChannel *</RETURNS>
int         fd
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_get_fd</NAME>
<RETURNS>gint  </RETURNS>
GIOChannel *channel
</FUNCTION>
<FUNCTION>
<NAME>g_io_channel_win32_new_stream_socket</NAME>
<RETURNS>GIOChannel  *</RETURNS>
int socket
</FUNCTION>
<MACRO>
<NAME>MAXPATHLEN</NAME>
#  define MAXPATHLEN 1024
</MACRO>
<TYPEDEF>
<NAME>pid_t</NAME>
typedef int pid_t;
</TYPEDEF>
<MACRO>
<NAME>pipe</NAME>
#define pipe(phandles)	_pipe (phandles, 4096, _O_BINARY)
</MACRO>
<MACRO>
<NAME>ftruncate</NAME>
#    define ftruncate(fd, size)	g_win32_ftruncate (fd, size)
</MACRO>
<MACRO>
<NAME>opendir</NAME>
#    define opendir		g_win32_opendir
</MACRO>
<MACRO>
<NAME>readdir</NAME>
#    define readdir		g_win32_readdir
</MACRO>
<MACRO>
<NAME>rewinddir</NAME>
#    define rewinddir		g_win32_rewinddir
</MACRO>
<MACRO>
<NAME>closedir</NAME>
#    define closedir		g_win32_closedir
</MACRO>
<MACRO>
<NAME>NAME_MAX</NAME>
#    define NAME_MAX 255
</MACRO>
<FUNCTION>
<NAME>g_win32_ftruncate</NAME>
<RETURNS>int 	</RETURNS>
gint		 f,guint		 size
</FUNCTION>
<FUNCTION>
<NAME>g_win32_opendir</NAME>
<RETURNS>DIR *</RETURNS>
const gchar	*dirname
</FUNCTION>
<FUNCTION>
<NAME>g_win32_rewinddir</NAME>
<RETURNS>void 	</RETURNS>
DIR		*dir
</FUNCTION>
<FUNCTION>
<NAME>g_win32_closedir</NAME>
<RETURNS>gint 	</RETURNS>
DIR		*dir
</FUNCTION>
<FUNCTION>
<NAME>g_win32_getlocale</NAME>
<RETURNS>gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_win32_error_message</NAME>
<RETURNS>gchar  *</RETURNS>
gint error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>G_THREAD_ERROR</NAME>
#define G_THREAD_ERROR g_thread_error_quark()
</MACRO>
<ENUM>
<NAME>GThreadError</NAME>
typedef enum
{
  G_THREAD_ERROR_AGAIN /* Resource temporarily unavailable */
} GThreadError;
</ENUM>
<USER_FUNCTION>
<NAME>GThreadFunc</NAME>
<RETURNS>void </RETURNS>
gpointer	value
</USER_FUNCTION>
<ENUM>
<NAME>GThreadPriority</NAME>
typedef enum
{
    G_THREAD_PRIORITY_LOW,
    G_THREAD_PRIORITY_NORMAL,
    G_THREAD_PRIORITY_HIGH,
    G_THREAD_PRIORITY_URGENT
} GThreadPriority;
</ENUM>
<STRUCT>
<NAME>GThread</NAME>
</STRUCT>
<STRUCT>
<NAME>GThread</NAME>
struct GThread
{
  GThreadPriority priority;
  gboolean bound;
  gboolean joinable;
};
</STRUCT>
<STRUCT>
<NAME>GMutex</NAME>
</STRUCT>
<STRUCT>
<NAME>GCond</NAME>
</STRUCT>
<STRUCT>
<NAME>GPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GStaticPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GAsyncQueue</NAME>
</STRUCT>
<STRUCT>
<NAME>GThreadPool</NAME>
</STRUCT>
<STRUCT>
<NAME>GThreadFunctions</NAME>
</STRUCT>
<STRUCT>
<NAME>GThreadFunctions</NAME>
struct GThreadFunctions
{
  GMutex*  (*mutex_new)           (void);
  void     (*mutex_lock)          (GMutex		*mutex);
  gboolean (*mutex_trylock)       (GMutex		*mutex);
  void     (*mutex_unlock)        (GMutex		*mutex);
  void     (*mutex_free)          (GMutex		*mutex);
  GCond*   (*cond_new)            (void);
  void     (*cond_signal)         (GCond		*cond);
  void     (*cond_broadcast)      (GCond		*cond);
  void     (*cond_wait)           (GCond		*cond,
			           GMutex		*mutex);
  gboolean (*cond_timed_wait)     (GCond		*cond,
			           GMutex		*mutex, 
			           GTimeVal 		*end_time);
  void      (*cond_free)          (GCond		*cond);
  GPrivate* (*private_new)        (GDestroyNotify	 destructor);
  gpointer  (*private_get)        (GPrivate		*private_key);
  void      (*private_set)        (GPrivate		*private_key,
			           gpointer		 data);
  void      (*thread_create)      (GThreadFunc 		 thread_func,
			           gpointer 		 arg,
			           gulong 		 stack_size,
			           gboolean 		 joinable,
			           gboolean 		 bound,
			           GThreadPriority 	 priority,
				   gpointer              thread,
				   GError              **error);
  void      (*thread_yield)       (void);
  void      (*thread_join)        (gpointer		 thread);
  void      (*thread_exit)        (void);
  void      (*thread_set_priority)(gpointer		 thread, 
				   GThreadPriority 	 priority);
  void      (*thread_self)        (gpointer              thread);
};
</STRUCT>
<FUNCTION>
<NAME>g_thread_init</NAME>
<RETURNS>void 	</RETURNS>
GThreadFunctions	*vtable
</FUNCTION>
<FUNCTION>
<NAME>g_static_mutex_get_mutex_impl</NAME>
<RETURNS>GMutex *</RETURNS>
GMutex	**mutex
</FUNCTION>
<MACRO>
<NAME>G_THREAD_UF</NAME>
#define G_THREAD_UF(name, arglist) \
    (*g_thread_functions_for_glib_use . name) arglist
</MACRO>
<MACRO>
<NAME>G_THREAD_CF</NAME>
#define G_THREAD_CF(name, fail, arg) \
    (g_thread_supported () ? G_THREAD_UF (name, arg) : (fail))
</MACRO>
<MACRO>
<NAME>g_thread_supported</NAME>
#define	g_thread_supported()	(g_threads_got_initialized)
</MACRO>
<MACRO>
<NAME>g_mutex_new</NAME>
#define g_mutex_new()            G_THREAD_UF (mutex_new,      ())
</MACRO>
<MACRO>
<NAME>g_mutex_lock</NAME>
#define g_mutex_lock(mutex)      G_THREAD_CF (mutex_lock,     (void)0, (mutex))
</MACRO>
<MACRO>
<NAME>g_mutex_trylock</NAME>
#define g_mutex_trylock(mutex)   G_THREAD_CF (mutex_trylock,  TRUE,    (mutex))
</MACRO>
<MACRO>
<NAME>g_mutex_unlock</NAME>
#define g_mutex_unlock(mutex)    G_THREAD_CF (mutex_unlock,   (void)0, (mutex))
</MACRO>
<MACRO>
<NAME>g_mutex_free</NAME>
#define g_mutex_free(mutex)      G_THREAD_CF (mutex_free,     (void)0, (mutex))
</MACRO>
<MACRO>
<NAME>g_cond_new</NAME>
#define g_cond_new()             G_THREAD_UF (cond_new,       ())
</MACRO>
<MACRO>
<NAME>g_cond_signal</NAME>
#define g_cond_signal(cond)      G_THREAD_CF (cond_signal,    (void)0, (cond))
</MACRO>
<MACRO>
<NAME>g_cond_broadcast</NAME>
#define g_cond_broadcast(cond)   G_THREAD_CF (cond_broadcast, (void)0, (cond))
</MACRO>
<MACRO>
<NAME>g_cond_wait</NAME>
#define g_cond_wait(cond, mutex) G_THREAD_CF (cond_wait,      (void)0, (cond, \
                                                                        mutex))
</MACRO>
<MACRO>
<NAME>g_cond_free</NAME>
#define g_cond_free(cond)        G_THREAD_CF (cond_free,      (void)0, (cond))
</MACRO>
<MACRO>
<NAME>g_cond_timed_wait</NAME>
#define g_cond_timed_wait(cond, mutex, abs_time) G_THREAD_CF (cond_timed_wait, \
                                                              TRUE, \
                                                              (cond, mutex, \
							       abs_time))
</MACRO>
<MACRO>
<NAME>g_private_new</NAME>
#define g_private_new(destructor)	  G_THREAD_UF (private_new, (destructor))
</MACRO>
<MACRO>
<NAME>g_private_get</NAME>
#define g_private_get(private_key)	  G_THREAD_CF (private_get, \
                                                       ((gpointer)private_key), \
                                                       (private_key))
</MACRO>
<MACRO>
<NAME>g_private_set</NAME>
#define g_private_set(private_key, value) G_THREAD_CF (private_set, \
                                                       (void) (private_key = \
                                                        (GPrivate*) (value)), \
                                                       (private_key, value))
</MACRO>
<MACRO>
<NAME>g_thread_yield</NAME>
#define g_thread_yield()              G_THREAD_CF (thread_yield, (void)0, ())
</MACRO>
<MACRO>
<NAME>g_thread_exit</NAME>
#define g_thread_exit()               G_THREAD_CF (thread_exit, (void)0, ())
</MACRO>
<FUNCTION>
<NAME>g_thread_create</NAME>
<RETURNS>GThread *</RETURNS>
GThreadFunc 		 thread_func,gpointer 		 arg,gulong 		 stack_size,gboolean 		 joinable,gboolean 		 bound,GThreadPriority 	 priority,GError               **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_self</NAME>
<RETURNS>GThread *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>g_thread_join</NAME>
<RETURNS>void  </RETURNS>
GThread *thread
</FUNCTION>
<FUNCTION>
<NAME>g_thread_set_priority</NAME>
<RETURNS>void  </RETURNS>
GThread         *thread,GThreadPriority  priority
</FUNCTION>
<MACRO>
<NAME>g_static_mutex_lock</NAME>
#define g_static_mutex_lock(mutex) \
    g_mutex_lock (g_static_mutex_get_mutex (mutex))
</MACRO>
<MACRO>
<NAME>g_static_mutex_trylock</NAME>
#define g_static_mutex_trylock(mutex) \
    g_mutex_trylock (g_static_mutex_get_mutex (mutex))
</MACRO>
<MACRO>
<NAME>g_static_mutex_unlock</NAME>
#define g_static_mutex_unlock(mutex) \
    g_mutex_unlock (g_static_mutex_get_mutex (mutex)) 
</MACRO>
<STRUCT>
<NAME>GStaticPrivate</NAME>
struct GStaticPrivate
{
  guint index;
};
</STRUCT>
<MACRO>
<NAME>G_STATIC_PRIVATE_INIT</NAME>
#define G_STATIC_PRIVATE_INIT { 0 }
</MACRO>
<FUNCTION>
<NAME>g_static_private_get</NAME>
<RETURNS>gpointer  </RETURNS>
GStaticPrivate	*private_key
</FUNCTION>
<FUNCTION>
<NAME>g_static_private_set</NAME>
<RETURNS>void  </RETURNS>
GStaticPrivate	*private_key,gpointer        	 data,GDestroyNotify    notify
</FUNCTION>
<FUNCTION>
<NAME>g_static_private_get_for_thread</NAME>
<RETURNS>gpointer  </RETURNS>
GStaticPrivate *private_key,GThread        *thread
</FUNCTION>
<FUNCTION>
<NAME>g_static_private_set_for_thread</NAME>
<RETURNS>void  </RETURNS>
GStaticPrivate *private_key,GThread        *thread,gpointer        data,GDestroyNotify  notify
</FUNCTION>
<STRUCT>
<NAME>GStaticRecMutex</NAME>
</STRUCT>
<STRUCT>
<NAME>GStaticRecMutex</NAME>
struct GStaticRecMutex
{
  GStaticMutex mutex;
  unsigned int depth;
  GSystemThread owner;
};
</STRUCT>
<MACRO>
<NAME>G_STATIC_REC_MUTEX_INIT</NAME>
#define G_STATIC_REC_MUTEX_INIT { G_STATIC_MUTEX_INIT }
</MACRO>
<FUNCTION>
<NAME>g_static_rec_mutex_lock</NAME>
<RETURNS>void  </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_trylock</NAME>
<RETURNS>gboolean  </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_unlock</NAME>
<RETURNS>void  </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_lock_full</NAME>
<RETURNS>void  </RETURNS>
GStaticRecMutex *mutex,guint            depth
</FUNCTION>
<FUNCTION>
<NAME>g_static_rec_mutex_unlock_full</NAME>
<RETURNS>guint  </RETURNS>
GStaticRecMutex *mutex
</FUNCTION>
<STRUCT>
<NAME>GStaticRWLock</NAME>
</STRUCT>
<STRUCT>
<NAME>GStaticRWLock</NAME>
struct GStaticRWLock
{
  GStaticMutex mutex; 
  GCond *read_cond;
  GCond *write_cond;
  guint read_counter;
  gboolean write;
  guint want_to_write;
};
</STRUCT>
<MACRO>
<NAME>G_STATIC_RW_LOCK_INIT</NAME>
#define G_STATIC_RW_LOCK_INIT { G_STATIC_MUTEX_INIT, NULL, NULL, 0, FALSE, FALSE }
</MACRO>
<FUNCTION>
<NAME>g_static_rw_lock_reader_lock</NAME>
<RETURNS>void  </RETURNS>
GStaticRWLock* lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_reader_trylock</NAME>
<RETURNS>gboolean  </RETURNS>
GStaticRWLock* lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_reader_unlock</NAME>
<RETURNS>void  </RETURNS>
GStaticRWLock* lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_writer_lock</NAME>
<RETURNS>void  </RETURNS>
GStaticRWLock* lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_writer_trylock</NAME>
<RETURNS>gboolean  </RETURNS>
GStaticRWLock* lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_writer_unlock</NAME>
<RETURNS>void  </RETURNS>
GStaticRWLock* lock
</FUNCTION>
<FUNCTION>
<NAME>g_static_rw_lock_free</NAME>
<RETURNS>void  </RETURNS>
GStaticRWLock* lock
</FUNCTION>
<FUNCTION>
<NAME>glib_dummy_decl</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_LOCK_NAME</NAME>
#define G_LOCK_NAME(name)		g__ ## name ## _lock
</MACRO>
<MACRO>
<NAME>G_LOCK_DEFINE_STATIC</NAME>
#  define G_LOCK_DEFINE_STATIC(name)	static G_LOCK_DEFINE (name)
</MACRO>
<MACRO>
<NAME>G_LOCK_DEFINE</NAME>
#  define G_LOCK_DEFINE(name)		\
    GStaticMutex G_LOCK_NAME (name) = G_STATIC_MUTEX_INIT 
</MACRO>
<MACRO>
<NAME>G_LOCK_EXTERN</NAME>
#  define G_LOCK_EXTERN(name)		extern GStaticMutex G_LOCK_NAME (name)
</MACRO>
<MACRO>
<NAME>G_LOCK</NAME>
#    define G_LOCK(name)		G_STMT_START{		  \
        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,			  \
	       "file %s: line %d (%s): locking: %s ",	          \
	       __FILE__,	__LINE__, G_GNUC_PRETTY_FUNCTION, \
               #name);                                            \
        g_static_mutex_lock (&G_LOCK_NAME (name));                \
     }G_STMT_END
</MACRO>
<MACRO>
<NAME>G_UNLOCK</NAME>
#    define G_UNLOCK(name)		G_STMT_START{		  \
        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,			  \
	       "file %s: line %d (%s): unlocking: %s ",	          \
	       __FILE__,	__LINE__, G_GNUC_PRETTY_FUNCTION, \
               #name);                                            \
       g_static_mutex_unlock (&G_LOCK_NAME (name));               \
     }G_STMT_END
</MACRO>
<MACRO>
<NAME>G_TRYLOCK</NAME>
#    define G_TRYLOCK(name)					  \
        (g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,		  \
	       "file %s: line %d (%s): try locking: %s ",         \
	       __FILE__,	__LINE__, G_GNUC_PRETTY_FUNCTION, \
               #name), g_static_mutex_trylock (&G_LOCK_NAME (name)))
</MACRO>
<MACRO>
<NAME>G_LOCK</NAME>
#    define G_LOCK(name) g_static_mutex_lock	   (&G_LOCK_NAME (name)) 
</MACRO>
<MACRO>
<NAME>G_UNLOCK</NAME>
#    define G_UNLOCK(name) g_static_mutex_unlock   (&G_LOCK_NAME (name))
</MACRO>
<MACRO>
<NAME>G_TRYLOCK</NAME>
#    define G_TRYLOCK(name) g_static_mutex_trylock (&G_LOCK_NAME (name))
</MACRO>
<MACRO>
<NAME>G_LOCK_DEFINE_STATIC</NAME>
#  define G_LOCK_DEFINE_STATIC(name)	extern void glib_dummy_decl (void)
</MACRO>
<MACRO>
<NAME>G_LOCK_DEFINE</NAME>
#  define G_LOCK_DEFINE(name)		extern void glib_dummy_decl (void)
</MACRO>
<MACRO>
<NAME>G_LOCK_EXTERN</NAME>
#  define G_LOCK_EXTERN(name)		extern void glib_dummy_decl (void)
</MACRO>
<MACRO>
<NAME>G_LOCK</NAME>
#  define G_LOCK(name)
</MACRO>
<MACRO>
<NAME>G_UNLOCK</NAME>
#  define G_UNLOCK(name)
</MACRO>
<MACRO>
<NAME>G_TRYLOCK</NAME>
#  define G_TRYLOCK(name)		(TRUE)
</MACRO>
<FUNCTION>
<NAME>g_async_queue_new</NAME>
<RETURNS>GAsyncQueue *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_lock</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_unlock</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_ref</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_ref_unlocked</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_unref</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_unref_and_unlock</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_push_unlocked</NAME>
<RETURNS>void  </RETURNS>
GAsyncQueue *queue,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_pop</NAME>
<RETURNS>gpointer  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_pop_unlocked</NAME>
<RETURNS>gpointer  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_try_pop</NAME>
<RETURNS>gpointer  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_try_pop_unlocked</NAME>
<RETURNS>gpointer  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_timed_pop</NAME>
<RETURNS>gpointer  </RETURNS>
GAsyncQueue *queue,GTimeVal    *end_time
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_timed_pop_unlocked</NAME>
<RETURNS>gpointer  </RETURNS>
GAsyncQueue *queue,GTimeVal    *end_time
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_length</NAME>
<RETURNS>gint  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>g_async_queue_length_unlocked</NAME>
<RETURNS>gint  </RETURNS>
GAsyncQueue *queue
</FUNCTION>
<STRUCT>
<NAME>GThreadPool</NAME>
struct GThreadPool
{
  GFunc thread_func;
  gulong stack_size;
  gboolean bound; 
  GThreadPriority priority;
  gboolean exclusive;
  gpointer user_data;
};
</STRUCT>
<FUNCTION>
<NAME>g_thread_pool_new</NAME>
<RETURNS>GThreadPool *</RETURNS>
GFunc            thread_func,gint             max_threads,gulong           stack_size,gboolean         bound,GThreadPriority  priority,gboolean         exclusive,gpointer         user_data,GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_push</NAME>
<RETURNS>void  </RETURNS>
GThreadPool     *pool,gpointer         data,GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_set_max_threads</NAME>
<RETURNS>void  </RETURNS>
GThreadPool     *pool,gint             max_threads,GError         **error
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_max_threads</NAME>
<RETURNS>gint  </RETURNS>
GThreadPool     *pool
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_num_threads</NAME>
<RETURNS>guint  </RETURNS>
GThreadPool     *pool
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_unprocessed</NAME>
<RETURNS>guint  </RETURNS>
GThreadPool     *pool
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_free</NAME>
<RETURNS>void  </RETURNS>
GThreadPool     *pool,gboolean         immediate,gboolean         wait
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_set_max_unused_threads</NAME>
<RETURNS>void  </RETURNS>
gint      max_threads
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_max_unused_threads</NAME>
<RETURNS>gint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_get_num_unused_threads</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_thread_pool_stop_unused_threads</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>gunichar</NAME>
typedef guint32 gunichar;
</TYPEDEF>
<TYPEDEF>
<NAME>gunichar2</NAME>
typedef guint16 gunichar2;
</TYPEDEF>
<ENUM>
<NAME>GUnicodeType</NAME>
typedef enum {
  G_UNICODE_CONTROL,
  G_UNICODE_FORMAT,
  G_UNICODE_UNASSIGNED,
  G_UNICODE_PRIVATE_USE,
  G_UNICODE_SURROGATE,
  G_UNICODE_LOWERCASE_LETTER,
  G_UNICODE_MODIFIER_LETTER,
  G_UNICODE_OTHER_LETTER,
  G_UNICODE_TITLECASE_LETTER,
  G_UNICODE_UPPERCASE_LETTER,
  G_UNICODE_COMBINING_MARK,
  G_UNICODE_ENCLOSING_MARK,
  G_UNICODE_NON_SPACING_MARK,
  G_UNICODE_DECIMAL_NUMBER,
  G_UNICODE_LETTER_NUMBER,
  G_UNICODE_OTHER_NUMBER,
  G_UNICODE_CONNECT_PUNCTUATION,
  G_UNICODE_DASH_PUNCTUATION,
  G_UNICODE_CLOSE_PUNCTUATION,
  G_UNICODE_FINAL_PUNCTUATION,
  G_UNICODE_INITIAL_PUNCTUATION,
  G_UNICODE_OTHER_PUNCTUATION,
  G_UNICODE_OPEN_PUNCTUATION,
  G_UNICODE_CURRENCY_SYMBOL,
  G_UNICODE_MODIFIER_SYMBOL,
  G_UNICODE_MATH_SYMBOL,
  G_UNICODE_OTHER_SYMBOL,
  G_UNICODE_LINE_SEPARATOR,
  G_UNICODE_PARAGRAPH_SEPARATOR,
  G_UNICODE_SPACE_SEPARATOR
} GUnicodeType;
</ENUM>
<FUNCTION>
<NAME>g_get_charset</NAME>
<RETURNS>gboolean  </RETURNS>
char **charset
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isalnum</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isalpha</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_iscntrl</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isdigit</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isgraph</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_islower</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isprint</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_ispunct</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isspace</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isupper</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isxdigit</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_istitle</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_isdefined</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_iswide</NAME>
<RETURNS>gboolean  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_toupper</NAME>
<RETURNS>gunichar  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_tolower</NAME>
<RETURNS>gunichar  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_totitle</NAME>
<RETURNS>gunichar  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_digit_value</NAME>
<RETURNS>gint  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_xdigit_value</NAME>
<RETURNS>gint  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_type</NAME>
<RETURNS>GUnicodeType  </RETURNS>
gunichar c
</FUNCTION>
<FUNCTION>
<NAME>g_unicode_canonical_ordering</NAME>
<RETURNS>void  </RETURNS>
gunichar *string,size_t   len
</FUNCTION>
<FUNCTION>
<NAME>g_unicode_canonical_decomposition</NAME>
<RETURNS>gunichar  *</RETURNS>
gunichar  ch,size_t   *result_len
</FUNCTION>
<MACRO>
<NAME>GLIB_VAR</NAME>
#      define GLIB_VAR __declspec(dllexport)
</MACRO>
<MACRO>
<NAME>GLIB_VAR</NAME>
#      define GLIB_VAR extern __declspec(dllimport)
</MACRO>
<MACRO>
<NAME>GLIB_VAR</NAME>
#    define GLIB_VAR extern
</MACRO>
<MACRO>
<NAME>g_utf8_next_char</NAME>
#define g_utf8_next_char(p) (char *)((p) + g_utf8_skip[*(guchar *)(p)])
</MACRO>
<FUNCTION>
<NAME>g_utf8_get_char</NAME>
<RETURNS>gunichar  </RETURNS>
const gchar *p
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_offset_to_pointer</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str,gint         offset
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_pointer_to_offset</NAME>
<RETURNS>gint  </RETURNS>
const gchar *str,const gchar *pos
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_prev_char</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *p
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_find_next_char</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *p,const gchar *bound
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_find_prev_char</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *str,const gchar *p
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strlen</NAME>
<RETURNS>gint  </RETURNS>
const gchar *p,gint         max
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strncpy</NAME>
<RETURNS>gchar  *</RETURNS>
gchar       *dest,const gchar *src,size_t       n
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strchr</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *p,gunichar     ch
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_strrchr</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *p,gunichar     ch
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_to_utf16</NAME>
<RETURNS>gunichar2  *</RETURNS>
const gchar     *str,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_to_ucs4</NAME>
<RETURNS>gunichar  *</RETURNS>
const gchar     *str,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_utf16_to_ucs4</NAME>
<RETURNS>gunichar  *</RETURNS>
const gunichar2 *str,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_utf16_to_utf8</NAME>
<RETURNS>gchar  *</RETURNS>
const gunichar2 *str,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_ucs4_to_utf16</NAME>
<RETURNS>gunichar  *</RETURNS>
const gunichar  *str,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_ucs4_to_utf8</NAME>
<RETURNS>gchar  *</RETURNS>
const gunichar  *str,gint             len
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_to_utf8</NAME>
<RETURNS>gint  </RETURNS>
gunichar    c,char       *outbuf
</FUNCTION>
<MACRO>
<NAME>GLIB_HAVE_SYS_POLL_H</NAME>
#define GLIB_HAVE_SYS_POLL_H
</MACRO>
<MACRO>
<NAME>G_MINFLOAT</NAME>
#define G_MINFLOAT	FLT_MIN
</MACRO>
<MACRO>
<NAME>G_MAXFLOAT</NAME>
#define G_MAXFLOAT	FLT_MAX
</MACRO>
<MACRO>
<NAME>G_MINDOUBLE</NAME>
#define G_MINDOUBLE	DBL_MIN
</MACRO>
<MACRO>
<NAME>G_MAXDOUBLE</NAME>
#define G_MAXDOUBLE	DBL_MAX
</MACRO>
<MACRO>
<NAME>G_MINSHORT</NAME>
#define G_MINSHORT	SHRT_MIN
</MACRO>
<MACRO>
<NAME>G_MAXSHORT</NAME>
#define G_MAXSHORT	SHRT_MAX
</MACRO>
<MACRO>
<NAME>G_MAXUSHORT</NAME>
#define G_MAXUSHORT	USHRT_MAX
</MACRO>
<MACRO>
<NAME>G_MININT</NAME>
#define G_MININT	INT_MIN
</MACRO>
<MACRO>
<NAME>G_MAXINT</NAME>
#define G_MAXINT	INT_MAX
</MACRO>
<MACRO>
<NAME>G_MAXUINT</NAME>
#define G_MAXUINT	UINT_MAX
</MACRO>
<MACRO>
<NAME>G_MINLONG</NAME>
#define G_MINLONG	LONG_MIN
</MACRO>
<MACRO>
<NAME>G_MAXLONG</NAME>
#define G_MAXLONG	LONG_MAX
</MACRO>
<MACRO>
<NAME>G_MAXULONG</NAME>
#define G_MAXULONG	ULONG_MAX
</MACRO>
<TYPEDEF>
<NAME>gint8</NAME>
typedef signed char gint8;
</TYPEDEF>
<TYPEDEF>
<NAME>guint8</NAME>
typedef unsigned char guint8;
</TYPEDEF>
<TYPEDEF>
<NAME>gint16</NAME>
typedef signed short gint16;
</TYPEDEF>
<TYPEDEF>
<NAME>guint16</NAME>
typedef unsigned short guint16;
</TYPEDEF>
<MACRO>
<NAME>G_GINT16_FORMAT</NAME>
#define G_GINT16_FORMAT "hi"
</MACRO>
<MACRO>
<NAME>G_GUINT16_FORMAT</NAME>
#define G_GUINT16_FORMAT "hu"
</MACRO>
<TYPEDEF>
<NAME>gint32</NAME>
typedef signed int gint32;
</TYPEDEF>
<TYPEDEF>
<NAME>guint32</NAME>
typedef unsigned int guint32;
</TYPEDEF>
<MACRO>
<NAME>G_GINT32_FORMAT</NAME>
#define G_GINT32_FORMAT "i"
</MACRO>
<MACRO>
<NAME>G_GUINT32_FORMAT</NAME>
#define G_GUINT32_FORMAT "u"
</MACRO>
<MACRO>
<NAME>G_HAVE_GINT64</NAME>
#define G_HAVE_GINT64 1
</MACRO>
<TYPEDEF>
<NAME>gint64</NAME>
G_GNUC_EXTENSION typedef signed long long gint64;
</TYPEDEF>
<TYPEDEF>
<NAME>guint64</NAME>
G_GNUC_EXTENSION typedef unsigned long long guint64;
</TYPEDEF>
<MACRO>
<NAME>G_GINT64_FORMAT</NAME>
#define G_GINT64_FORMAT "lli"
</MACRO>
<MACRO>
<NAME>G_GUINT64_FORMAT</NAME>
#define G_GUINT64_FORMAT "llu"
</MACRO>
<MACRO>
<NAME>G_GINT64_CONSTANT</NAME>
#define G_GINT64_CONSTANT(val)	(G_GNUC_EXTENSION (val##LL))
</MACRO>
<TYPEDEF>
<NAME>gssize</NAME>
typedef gint32  gssize;
</TYPEDEF>
<TYPEDEF>
<NAME>gsize</NAME>
typedef guint32 gsize;
</TYPEDEF>
<MACRO>
<NAME>GPOINTER_TO_INT</NAME>
#define GPOINTER_TO_INT(p)	((gint)   (p))
</MACRO>
<MACRO>
<NAME>GPOINTER_TO_UINT</NAME>
#define GPOINTER_TO_UINT(p)	((guint)  (p))
</MACRO>
<MACRO>
<NAME>GINT_TO_POINTER</NAME>
#define GINT_TO_POINTER(i)	((gpointer)  (i))
</MACRO>
<MACRO>
<NAME>GUINT_TO_POINTER</NAME>
#define GUINT_TO_POINTER(u)	((gpointer)  (u))
</MACRO>
<MACRO>
<NAME>g_ATEXIT</NAME>
# define g_ATEXIT(proc)	(!atexit (proc))
</MACRO>
<MACRO>
<NAME>g_ATEXIT</NAME>
# define g_ATEXIT(proc)	(atexit (proc))
</MACRO>
<MACRO>
<NAME>g_memmove</NAME>
#define g_memmove(d,s,n) G_STMT_START { memmove ((d), (s), (n)); } G_STMT_END
</MACRO>
<MACRO>
<NAME>GLIB_MAJOR_VERSION</NAME>
#define GLIB_MAJOR_VERSION 1
</MACRO>
<MACRO>
<NAME>GLIB_MINOR_VERSION</NAME>
#define GLIB_MINOR_VERSION 3
</MACRO>
<MACRO>
<NAME>GLIB_MICRO_VERSION</NAME>
#define GLIB_MICRO_VERSION 1
</MACRO>
<MACRO>
<NAME>G_OS_UNIX</NAME>
#define G_OS_UNIX
</MACRO>
<MACRO>
<NAME>G_VA_COPY</NAME>
#define G_VA_COPY	__va_copy
</MACRO>
<MACRO>
<NAME>G_HAVE_INLINE</NAME>
#define	G_HAVE_INLINE	1
</MACRO>
<MACRO>
<NAME>G_HAVE_INLINE</NAME>
#define G_HAVE_INLINE 1
</MACRO>
<MACRO>
<NAME>G_HAVE___INLINE</NAME>
#define G_HAVE___INLINE 1
</MACRO>
<MACRO>
<NAME>G_HAVE___INLINE__</NAME>
#define G_HAVE___INLINE__ 1
</MACRO>
<MACRO>
<NAME>G_THREADS_ENABLED</NAME>
#define G_THREADS_ENABLED
</MACRO>
<MACRO>
<NAME>G_THREADS_IMPL_POSIX</NAME>
#define G_THREADS_IMPL_POSIX
</MACRO>
<STRUCT>
<NAME>GStaticMutex</NAME>
</STRUCT>
<STRUCT>
<NAME>GStaticMutex</NAME>
struct GStaticMutex
{
  struct _GMutex *runtime_mutex;
  union {
    char   pad[24];
    double dummy_double;
    void  *dummy_pointer;
    long   dummy_long;
  } aligned_pad_u;
};
</STRUCT>
<MACRO>
<NAME>G_STATIC_MUTEX_INIT</NAME>
#define	G_STATIC_MUTEX_INIT	{ NULL, { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} } }
</MACRO>
<MACRO>
<NAME>g_static_mutex_get_mutex</NAME>
#define	g_static_mutex_get_mutex(mutex)   (g_thread_use_default_impl ? ((GMutex*) &((mutex)->aligned_pad_u)) :    g_static_mutex_get_mutex_impl (&((mutex)->runtime_mutex)))
</MACRO>
<UNION>
<NAME>GSystemThread</NAME>
union GSystemThread
{
  char   data[4];
  double dummy_double;
  void  *dummy_pointer;
  long   dummy_long;
};
</UNION>
<MACRO>
<NAME>GINT16_TO_LE</NAME>
#define GINT16_TO_LE(val)	((gint16) (val))
</MACRO>
<MACRO>
<NAME>GUINT16_TO_LE</NAME>
#define GUINT16_TO_LE(val)	((guint16) (val))
</MACRO>
<MACRO>
<NAME>GINT16_TO_BE</NAME>
#define GINT16_TO_BE(val)	((gint16) GUINT16_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT16_TO_BE</NAME>
#define GUINT16_TO_BE(val)	(GUINT16_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GINT32_TO_LE</NAME>
#define GINT32_TO_LE(val)	((gint32) (val))
</MACRO>
<MACRO>
<NAME>GUINT32_TO_LE</NAME>
#define GUINT32_TO_LE(val)	((guint32) (val))
</MACRO>
<MACRO>
<NAME>GINT32_TO_BE</NAME>
#define GINT32_TO_BE(val)	((gint32) GUINT32_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT32_TO_BE</NAME>
#define GUINT32_TO_BE(val)	(GUINT32_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GINT64_TO_LE</NAME>
#define GINT64_TO_LE(val)	((gint64) (val))
</MACRO>
<MACRO>
<NAME>GUINT64_TO_LE</NAME>
#define GUINT64_TO_LE(val)	((guint64) (val))
</MACRO>
<MACRO>
<NAME>GINT64_TO_BE</NAME>
#define GINT64_TO_BE(val)	((gint64) GUINT64_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT64_TO_BE</NAME>
#define GUINT64_TO_BE(val)	(GUINT64_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GLONG_TO_LE</NAME>
#define GLONG_TO_LE(val)	((glong) GINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GULONG_TO_LE</NAME>
#define GULONG_TO_LE(val)	((gulong) GUINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GLONG_TO_BE</NAME>
#define GLONG_TO_BE(val)	((glong) GINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GULONG_TO_BE</NAME>
#define GULONG_TO_BE(val)	((gulong) GUINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GINT_TO_LE</NAME>
#define GINT_TO_LE(val)		((gint) GINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GUINT_TO_LE</NAME>
#define GUINT_TO_LE(val)	((guint) GUINT32_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GINT_TO_BE</NAME>
#define GINT_TO_BE(val)		((gint) GINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GUINT_TO_BE</NAME>
#define GUINT_TO_BE(val)	((guint) GUINT32_TO_BE (val))
</MACRO>
<MACRO>
<NAME>G_BYTE_ORDER</NAME>
#define G_BYTE_ORDER G_LITTLE_ENDIAN
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLIN</NAME>
#define GLIB_SYSDEF_POLLIN =1
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLOUT</NAME>
#define GLIB_SYSDEF_POLLOUT =4
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLPRI</NAME>
#define GLIB_SYSDEF_POLLPRI =2
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLERR</NAME>
#define GLIB_SYSDEF_POLLERR =8
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLHUP</NAME>
#define GLIB_SYSDEF_POLLHUP =16
</MACRO>
<MACRO>
<NAME>GLIB_SYSDEF_POLLNVAL</NAME>
#define GLIB_SYSDEF_POLLNVAL =32
</MACRO>
<VARIABLE>
<NAME>g_log_domain_gmodule</NAME>
extern const char      *g_log_domain_gmodule;
</VARIABLE>
<MACRO>
<NAME>G_MODULE_IMPORT</NAME>
#define	G_MODULE_IMPORT		extern
</MACRO>
<MACRO>
<NAME>G_MODULE_EXPORT</NAME>
#  define	G_MODULE_EXPORT		__declspec(dllexport)
</MACRO>
<MACRO>
<NAME>G_MODULE_EXPORT</NAME>
#  define	G_MODULE_EXPORT
</MACRO>
<ENUM>
<NAME>GModuleFlags</NAME>
typedef enum
{
  G_MODULE_BIND_LAZY	= 1 << 0,
  G_MODULE_BIND_MASK	= 0x01
} GModuleFlags;
</ENUM>
<STRUCT>
<NAME>GModule</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GModuleCheckInit</NAME>
<RETURNS>const gchar *</RETURNS>
GModule	*module
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GModuleUnload</NAME>
<RETURNS>void </RETURNS>
GModule	*module
</USER_FUNCTION>
<FUNCTION>
<NAME>g_module_supported</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_module_open</NAME>
<RETURNS>GModule *</RETURNS>
const gchar		*file_name,GModuleFlags	 flags
</FUNCTION>
<FUNCTION>
<NAME>g_module_close</NAME>
<RETURNS>gboolean 	</RETURNS>
GModule		*module
</FUNCTION>
<FUNCTION>
<NAME>g_module_make_resident</NAME>
<RETURNS>void 	</RETURNS>
GModule		*module
</FUNCTION>
<FUNCTION>
<NAME>g_module_error</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_module_symbol</NAME>
<RETURNS>gboolean 	</RETURNS>
GModule		*module,const gchar		*symbol_name,gpointer		*symbol
</FUNCTION>
<FUNCTION>
<NAME>g_module_name</NAME>
<RETURNS>gchar *</RETURNS>
GModule		*module
</FUNCTION>
<FUNCTION>
<NAME>g_module_build_path</NAME>
<RETURNS>gchar *</RETURNS>
const gchar		*directory,const gchar		*module_name
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IS_ENUM</NAME>
#define G_TYPE_IS_ENUM(type)	       (G_TYPE_FUNDAMENTAL (type) == G_TYPE_ENUM)
</MACRO>
<MACRO>
<NAME>G_ENUM_CLASS</NAME>
#define G_ENUM_CLASS(class)	       (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_ENUM, GEnumClass))
</MACRO>
<MACRO>
<NAME>G_IS_ENUM_CLASS</NAME>
#define G_IS_ENUM_CLASS(class)	       (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_ENUM))
</MACRO>
<MACRO>
<NAME>G_ENUM_CLASS_TYPE</NAME>
#define G_ENUM_CLASS_TYPE(class)       (G_TYPE_FROM_CLASS (class))
</MACRO>
<MACRO>
<NAME>G_ENUM_CLASS_TYPE_NAME</NAME>
#define G_ENUM_CLASS_TYPE_NAME(class)  (g_type_name (G_ENUM_TYPE (class)))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_FLAGS</NAME>
#define G_TYPE_IS_FLAGS(type)	       (G_TYPE_FUNDAMENTAL (type) == G_TYPE_FLAGS)
</MACRO>
<MACRO>
<NAME>G_FLAGS_CLASS</NAME>
#define G_FLAGS_CLASS(class)	       (G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_FLAGS, GFlagsClass))
</MACRO>
<MACRO>
<NAME>G_IS_FLAGS_CLASS</NAME>
#define G_IS_FLAGS_CLASS(class)        (G_TYPE_CHECK_CLASS_TYPE ((class), G_TYPE_FLAGS))
</MACRO>
<MACRO>
<NAME>G_FLAGS_CLASS_TYPE</NAME>
#define G_FLAGS_CLASS_TYPE(class)      (G_TYPE_FROM_CLASS (class))
</MACRO>
<MACRO>
<NAME>G_FLAGS_CLASS_TYPE_NAME</NAME>
#define G_FLAGS_CLASS_TYPE_NAME(class) (g_type_name (G_FLAGS_TYPE (class)))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_ENUM</NAME>
#define G_IS_VALUE_ENUM(value)         (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_ENUM))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_FLAGS</NAME>
#define G_IS_VALUE_FLAGS(value)        (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_FLAGS))
</MACRO>
<STRUCT>
<NAME>GEnumClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GFlagsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GEnumValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GFlagsValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GEnumValue</NAME>
struct GEnumValue
{
  gint	 value;
  gchar *value_name;
  gchar *value_nick;
};
</STRUCT>
<STRUCT>
<NAME>GFlagsValue</NAME>
struct GFlagsValue
{
  guint	 value;
  gchar *value_name;
  gchar *value_nick;
};
</STRUCT>
<FUNCTION>
<NAME>g_enum_get_value</NAME>
<RETURNS>GEnumValue *</RETURNS>
GEnumClass	*enum_class,gint		 value
</FUNCTION>
<FUNCTION>
<NAME>g_enum_get_value_by_name</NAME>
<RETURNS>GEnumValue *</RETURNS>
GEnumClass	*enum_class,const gchar	*name
</FUNCTION>
<FUNCTION>
<NAME>g_enum_get_value_by_nick</NAME>
<RETURNS>GEnumValue *</RETURNS>
GEnumClass	*enum_class,const gchar	*nick
</FUNCTION>
<FUNCTION>
<NAME>g_flags_get_first_value</NAME>
<RETURNS>GFlagsValue *</RETURNS>
GFlagsClass	*flags_class,guint		 value
</FUNCTION>
<FUNCTION>
<NAME>g_flags_get_value_by_name</NAME>
<RETURNS>GFlagsValue *</RETURNS>
GFlagsClass	*flags_class,const gchar	*name
</FUNCTION>
<FUNCTION>
<NAME>g_flags_get_value_by_nick</NAME>
<RETURNS>GFlagsValue *</RETURNS>
GFlagsClass	*flags_class,const gchar	*nick
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_enum</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,gint            v_enum
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_enum</NAME>
<RETURNS>gint  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_flags</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,guint           v_flags
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_flags</NAME>
<RETURNS>guint  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_enum_register_static</NAME>
<RETURNS>GType 	</RETURNS>
const gchar	      *name,const GEnumValue  *const_static_values
</FUNCTION>
<FUNCTION>
<NAME>g_flags_register_static</NAME>
<RETURNS>GType 	</RETURNS>
const gchar	      *name,const GFlagsValue *const_static_values
</FUNCTION>
<FUNCTION>
<NAME>g_enum_complete_type_info</NAME>
<RETURNS>void 	</RETURNS>
GType	       g_enum_type,GTypeInfo	      *info,const GEnumValue  *const_values
</FUNCTION>
<FUNCTION>
<NAME>g_flags_complete_type_info</NAME>
<RETURNS>void 	</RETURNS>
GType	       g_flags_type,GTypeInfo	      *info,const GFlagsValue *const_values
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IS_OBJECT</NAME>
#define G_TYPE_IS_OBJECT(type)	   (G_TYPE_FUNDAMENTAL (type) == G_TYPE_OBJECT)
</MACRO>
<MACRO>
<NAME>G_OBJECT</NAME>
#define G_OBJECT(object)	   (G_IS_OBJECT (object) ? ((GObject*) (object)) : \
				    G_TYPE_CHECK_INSTANCE_CAST ((object), G_TYPE_OBJECT, GObject))
</MACRO>
<MACRO>
<NAME>G_OBJECT_CLASS</NAME>
#define G_OBJECT_CLASS(class)	   (G_IS_OBJECT_CLASS (class) ? ((GObjectClass*) (class)) : \
				    G_TYPE_CHECK_CLASS_CAST ((class), G_TYPE_OBJECT, GObjectClass))
</MACRO>
<MACRO>
<NAME>G_IS_OBJECT</NAME>
#define G_IS_OBJECT(object)	   (((GObject*) (object)) != NULL && \
				    G_IS_OBJECT_CLASS (((GTypeInstance*) (object))->g_class))
</MACRO>
<MACRO>
<NAME>G_IS_OBJECT_CLASS</NAME>
#define G_IS_OBJECT_CLASS(class)   (((GTypeClass*) (class)) != NULL && \
				    G_TYPE_IS_OBJECT (((GTypeClass*) (class))->g_type))
</MACRO>
<MACRO>
<NAME>G_OBJECT_GET_CLASS</NAME>
#define G_OBJECT_GET_CLASS(object) (G_TYPE_INSTANCE_GET_CLASS ((object), G_TYPE_OBJECT, GObjectClass))
</MACRO>
<MACRO>
<NAME>G_OBJECT_TYPE</NAME>
#define G_OBJECT_TYPE(object)	   (G_TYPE_FROM_INSTANCE (object))
</MACRO>
<MACRO>
<NAME>G_OBJECT_TYPE_NAME</NAME>
#define G_OBJECT_TYPE_NAME(object) (g_type_name (G_OBJECT_TYPE (object)))
</MACRO>
<MACRO>
<NAME>G_OBJECT_CLASS_TYPE</NAME>
#define G_OBJECT_CLASS_TYPE(class) (G_TYPE_FROM_CLASS (class))
</MACRO>
<MACRO>
<NAME>G_OBJECT_CLASS_NAME</NAME>
#define G_OBJECT_CLASS_NAME(class) (g_type_name (G_OBJECT_CLASS_TYPE (class)))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_OBJECT</NAME>
#define G_IS_VALUE_OBJECT(value)   (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_OBJECT))
</MACRO>
<MACRO>
<NAME>G_NOTIFY_PRIORITY</NAME>
#define	G_NOTIFY_PRIORITY	   (G_PRIORITY_HIGH_IDLE + 20)
</MACRO>
<STRUCT>
<NAME>GObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GObjectClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GObjectGetParamFunc</NAME>
<RETURNS>void </RETURNS>
GObject     *object,
					 guint	      param_id,
					 GValue	     *value,
					 GParamSpec  *pspec,
					 const gchar *trailer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GObjectSetParamFunc</NAME>
<RETURNS>void </RETURNS>
GObject     *object,
					 guint	      param_id,
					 GValue	     *value,
					 GParamSpec  *pspec,
					 const gchar *trailer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GObjectFinalizeFunc</NAME>
<RETURNS>void </RETURNS>
GObject     *object
</USER_FUNCTION>
<STRUCT>
<NAME>GObject</NAME>
struct GObject
{
  GTypeInstance g_type_instance;
  
  /*< private >*/
  guint		ref_count;
  GData	       *qdata;
};
</STRUCT>
<FUNCTION>
<NAME>g_object_class_install_param</NAME>
<RETURNS>void 	</RETURNS>
GObjectClass   *oclass,guint	    param_id,GParamSpec	   *pspec
</FUNCTION>
<FUNCTION>
<NAME>g_object_class_find_param_spec</NAME>
<RETURNS>GParamSpec *</RETURNS>
GObjectClass   *oclass,const gchar	   *param_name
</FUNCTION>
<FUNCTION>
<NAME>g_object_new</NAME>
<RETURNS>gpointer  </RETURNS>
GType	    object_type,const gchar	   *first_param_name,...
</FUNCTION>
<FUNCTION>
<NAME>g_object_new_valist</NAME>
<RETURNS>gpointer  </RETURNS>
GType	    object_type,const gchar	   *first_param_name,va_list	    var_args
</FUNCTION>
<FUNCTION>
<NAME>g_object_set</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,const gchar	   *first_param_name,...
</FUNCTION>
<FUNCTION>
<NAME>g_object_get</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,const gchar	   *first_param_name,...
</FUNCTION>
<FUNCTION>
<NAME>g_object_set_valist</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,const gchar	   *first_param_name,va_list	    var_args
</FUNCTION>
<FUNCTION>
<NAME>g_object_get_valist</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,const gchar	   *first_param_name,va_list	    var_args
</FUNCTION>
<FUNCTION>
<NAME>g_object_set_param</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,const gchar    *param_name,const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>g_object_get_param</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,const gchar    *param_name,GValue	   *value
</FUNCTION>
<FUNCTION>
<NAME>g_object_queue_param_changed</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,const gchar	   *param_name
</FUNCTION>
<FUNCTION>
<NAME>g_object_ref</NAME>
<RETURNS>GObject *</RETURNS>
GObject	   *object
</FUNCTION>
<FUNCTION>
<NAME>g_object_unref</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object
</FUNCTION>
<FUNCTION>
<NAME>g_object_get_qdata</NAME>
<RETURNS>gpointer  </RETURNS>
GObject	   *object,GQuark	    quark
</FUNCTION>
<FUNCTION>
<NAME>g_object_set_qdata</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,GQuark	    quark,gpointer	    data
</FUNCTION>
<FUNCTION>
<NAME>g_object_set_qdata_full</NAME>
<RETURNS>void 	</RETURNS>
GObject	   *object,GQuark	    quark,gpointer	    data,GDestroyNotify  destroy
</FUNCTION>
<FUNCTION>
<NAME>g_object_steal_qdata</NAME>
<RETURNS>gpointer  </RETURNS>
GObject	   *object,GQuark	    quark
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_object</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,GObject        *v_object
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_object</NAME>
<RETURNS>GObject *</RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_dup_object</NAME>
<RETURNS>GObject *</RETURNS>
GValue         *value
</FUNCTION>
<MACRO>
<NAME>G_WARN_INVALID_PARAM_ID</NAME>
#define G_WARN_INVALID_PARAM_ID(object, param_id, pspec) \
G_STMT_START { \
  GObject *_object = (GObject*) (object); \
  GParamSpec *_pspec = (GParamSpec*) (pspec); \
  guint _param_id = (param_id); \
  g_warning ("%s: invalid parameter id %u for \"%s\" of type `%s' in `%s'", \
	     G_STRLOC, \
	     _param_id, \
	     _pspec->name, \
	     g_type_name (G_PARAM_SPEC_TYPE (_pspec)), \
	     BSE_OBJECT_TYPE_NAME (_object)); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_PARAM</NAME>
#define G_TYPE_IS_PARAM(type)		(G_TYPE_FUNDAMENTAL (type) == G_TYPE_PARAM)
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_TYPE</NAME>
#define G_PARAM_SPEC_TYPE(pspec)	(G_TYPE_FROM_INSTANCE (pspec))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_TYPE_NAME</NAME>
#define G_PARAM_SPEC_TYPE_NAME(pspec)	(g_type_name (G_PARAM_SPEC_TYPE (pspec)))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC</NAME>
#define G_PARAM_SPEC(pspec)		(G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM, GParamSpec))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC</NAME>
#define G_IS_PARAM_SPEC(pspec)		(G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_GET_CLASS</NAME>
#define G_PARAM_SPEC_GET_CLASS(pspec)	(G_TYPE_INSTANCE_GET_CLASS ((pspec), G_TYPE_PARAM, GParamSpecClass))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_VALUE</NAME>
#define	G_IS_PARAM_VALUE(pspec, value)	(g_type_is_a (G_VALUE_TYPE (value), G_PARAM_SPEC_VALUE_TYPE (pspec))) /* FIXME */
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_VALUE_TYPE</NAME>
#define	G_PARAM_SPEC_VALUE_TYPE(pspec)	(G_PARAM_SPEC_GET_CLASS (pspec)->value_type)
</MACRO>
<ENUM>
<NAME>GParamFlags</NAME>
typedef enum
{
  G_PARAM_READABLE            = 1 << 0,
  G_PARAM_WRITABLE            = 1 << 1,
  G_PARAM_MASK                = 0x000f,
  /* bits in the range 0xfff0 are reserved for 3rd party usage */
  G_PARAM_USER_MASK           = 0xfff0
} GParamFlags;
</ENUM>
<STRUCT>
<NAME>GParamSpecClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpec</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpec</NAME>
struct GParamSpec
{
  GTypeInstance  g_instance;

  gchar         *name;
  gchar         *nick;
  gchar         *blurb;
  GParamFlags    flags;

  /*< private >*/
  GType		 owner_type;
  GData		*qdata;
  guint          ref_count;
};
</STRUCT>
<FUNCTION>
<NAME>g_param_spec_ref</NAME>
<RETURNS>GParamSpec *</RETURNS>
GParamSpec    *pspec
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_unref</NAME>
<RETURNS>void 	</RETURNS>
GParamSpec    *pspec
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_get_qdata</NAME>
<RETURNS>gpointer  </RETURNS>
GParamSpec    *pspec,GQuark         quark
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_set_qdata</NAME>
<RETURNS>void  </RETURNS>
GParamSpec    *pspec,GQuark         quark,gpointer       data
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_set_qdata_full</NAME>
<RETURNS>void  </RETURNS>
GParamSpec    *pspec,GQuark         quark,gpointer       data,GDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_steal_qdata</NAME>
<RETURNS>gpointer  </RETURNS>
GParamSpec    *pspec,GQuark         quark
</FUNCTION>
<FUNCTION>
<NAME>g_param_value_set_default</NAME>
<RETURNS>void 	</RETURNS>
GParamSpec    *pspec,GValue	       *value
</FUNCTION>
<FUNCTION>
<NAME>g_param_value_defaults</NAME>
<RETURNS>gboolean 	</RETURNS>
GParamSpec    *pspec,GValue	       *value
</FUNCTION>
<FUNCTION>
<NAME>g_param_value_validate</NAME>
<RETURNS>gboolean 	</RETURNS>
GParamSpec    *pspec,GValue	       *value
</FUNCTION>
<FUNCTION>
<NAME>g_param_values_cmp</NAME>
<RETURNS>gint 	</RETURNS>
GParamSpec    *pspec,const GValue  *value1,const GValue  *value2
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_internal</NAME>
<RETURNS>gpointer 	</RETURNS>
GType	        param_type,const gchar   *name,const gchar   *nick,const gchar   *blurb,GParamFlags    flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_hash_table_new</NAME>
<RETURNS>GHashTable *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_hash_table_insert</NAME>
<RETURNS>void 	</RETURNS>
GHashTable    *hash_table,GParamSpec    *pspec,GType		owner_type
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_hash_table_remove</NAME>
<RETURNS>void 	</RETURNS>
GHashTable    *hash_table,GParamSpec    *pspec
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_hash_table_lookup</NAME>
<RETURNS>GParamSpec *</RETURNS>
GHashTable    *hash_table,const gchar   *param_name,GType		owner_type,gboolean       try_ancestors,const gchar  **trailer
</FUNCTION>
<MACRO>
<NAME>G_IS_PARAM_SPEC_CHAR</NAME>
#define G_IS_PARAM_SPEC_CHAR(pspec)     (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_CHAR))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_CHAR</NAME>
#define G_PARAM_SPEC_CHAR(pspec)        (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_CHAR, GParamSpecChar))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_UCHAR</NAME>
#define G_IS_PARAM_SPEC_UCHAR(pspec)    (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_UCHAR))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_UCHAR</NAME>
#define G_PARAM_SPEC_UCHAR(pspec)       (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_UCHAR, GParamSpecUChar))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_BOOLEAN</NAME>
#define G_IS_PARAM_SPEC_BOOLEAN(pspec)  (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_BOOLEAN))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_BOOLEAN</NAME>
#define G_PARAM_SPEC_BOOLEAN(pspec)     (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_BOOLEAN, GParamSpecBoolean))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_INT</NAME>
#define G_IS_PARAM_SPEC_INT(pspec)      (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_INT))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_INT</NAME>
#define G_PARAM_SPEC_INT(pspec)         (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_INT, GParamSpecInt))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_UINT</NAME>
#define G_IS_PARAM_SPEC_UINT(pspec)     (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_UINT))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_UINT</NAME>
#define G_PARAM_SPEC_UINT(pspec)        (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_UINT, GParamSpecUInt))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_LONG</NAME>
#define G_IS_PARAM_SPEC_LONG(pspec)     (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_LONG))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_LONG</NAME>
#define G_PARAM_SPEC_LONG(pspec)        (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_LONG, GParamSpecLong))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_ULONG</NAME>
#define G_IS_PARAM_SPEC_ULONG(pspec)    (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_ULONG))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_ULONG</NAME>
#define G_PARAM_SPEC_ULONG(pspec)       (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_ULONG, GParamSpecULong))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_ENUM</NAME>
#define G_IS_PARAM_SPEC_ENUM(pspec)     (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_ENUM))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_ENUM</NAME>
#define G_PARAM_SPEC_ENUM(pspec)        (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_ENUM, GParamSpecEnum))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_FLAGS</NAME>
#define G_IS_PARAM_SPEC_FLAGS(pspec)    (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_FLAGS))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_FLAGS</NAME>
#define G_PARAM_SPEC_FLAGS(pspec)       (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_FLAGS, GParamSpecFlags))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_FLOAT</NAME>
#define G_IS_PARAM_SPEC_FLOAT(pspec)    (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_FLOAT))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_FLOAT</NAME>
#define G_PARAM_SPEC_FLOAT(pspec)       (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_FLOAT, GParamSpecFloat))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_DOUBLE</NAME>
#define G_IS_PARAM_SPEC_DOUBLE(pspec)   (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_DOUBLE))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_DOUBLE</NAME>
#define G_PARAM_SPEC_DOUBLE(pspec)      (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_DOUBLE, GParamSpecDouble))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_STRING</NAME>
#define G_IS_PARAM_SPEC_STRING(pspec)   (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_STRING))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_STRING</NAME>
#define G_PARAM_SPEC_STRING(pspec)      (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_STRING, GParamSpecString))
</MACRO>
<MACRO>
<NAME>G_IS_PARAM_SPEC_OBJECT</NAME>
#define G_IS_PARAM_SPEC_OBJECT(pspec)   (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), G_TYPE_PARAM_OBJECT))
</MACRO>
<MACRO>
<NAME>G_PARAM_SPEC_OBJECT</NAME>
#define G_PARAM_SPEC_OBJECT(pspec)      (G_TYPE_CHECK_INSTANCE_CAST ((pspec), G_TYPE_PARAM_OBJECT, GParamSpecObject))
</MACRO>
<STRUCT>
<NAME>GParamSpecChar</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecUChar</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecBoolean</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecInt</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecUInt</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecLong</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecULong</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecEnum</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecFlags</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecFloat</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecDouble</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecString</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GParamSpecChar</NAME>
struct GParamSpecChar
{
  GParamSpec    parent_instance;
  
  gint8         minimum;
  gint8         maximum;
  gint8         default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecUChar</NAME>
struct GParamSpecUChar
{
  GParamSpec    parent_instance;
  
  guint8        minimum;
  guint8        maximum;
  guint8        default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecBoolean</NAME>
struct GParamSpecBoolean
{
  GParamSpec    parent_instance;
  
  gboolean      default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecInt</NAME>
struct GParamSpecInt
{
  GParamSpec    parent_instance;
  
  gint          minimum;
  gint          maximum;
  gint          default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecUInt</NAME>
struct GParamSpecUInt
{
  GParamSpec    parent_instance;
  
  guint         minimum;
  guint         maximum;
  guint         default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecLong</NAME>
struct GParamSpecLong
{
  GParamSpec    parent_instance;
  
  glong         minimum;
  glong         maximum;
  glong         default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecULong</NAME>
struct GParamSpecULong
{
  GParamSpec    parent_instance;
  
  gulong        minimum;
  gulong        maximum;
  gulong        default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecEnum</NAME>
struct GParamSpecEnum
{
  GParamSpec    parent_instance;
  
  GEnumClass   *enum_class;
  glong         default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecFlags</NAME>
struct GParamSpecFlags
{
  GParamSpec    parent_instance;
  
  GFlagsClass  *flags_class;
  gulong        default_value;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecFloat</NAME>
struct GParamSpecFloat
{
  GParamSpec    parent_instance;
  
  gfloat        minimum;
  gfloat        maximum;
  gfloat        default_value;
  gfloat        epsilon;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecDouble</NAME>
struct GParamSpecDouble
{
  GParamSpec    parent_instance;
  
  gdouble       minimum;
  gdouble       maximum;
  gdouble       default_value;
  gdouble       epsilon;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecString</NAME>
struct GParamSpecString
{
  GParamSpec    parent_instance;
  
  gchar        *default_value;
  gchar        *cset_first;
  gchar        *cset_nth;
  gchar         substitutor;
  guint         null_fold_if_empty : 1;
  guint         ensure_non_null : 1;
};
</STRUCT>
<STRUCT>
<NAME>GParamSpecObject</NAME>
struct GParamSpecObject
{
  GParamSpec    parent_instance;
  
  GType         object_type;
};
</STRUCT>
<FUNCTION>
<NAME>g_param_spec_char</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,gint8           minimum,gint8           maximum,gint8           default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_uchar</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,guint8          minimum,guint8          maximum,guint8          default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_boolean</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,gboolean        default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_int</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,gint            minimum,gint            maximum,gint            default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_uint</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,guint           minimum,guint           maximum,guint           default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_long</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,glong           minimum,glong           maximum,glong           default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_ulong</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,gulong          minimum,gulong          maximum,gulong          default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_enum</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,GType           enum_type,gint            default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_flags</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,GType           flags_type,guint           default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_float</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,gfloat          minimum,gfloat          maximum,gfloat          default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_double</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,gdouble         minimum,gdouble         maximum,gdouble         default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_string</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,const gchar    *default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_string_c</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,const gchar    *default_value,GParamFlags     flags
</FUNCTION>
<FUNCTION>
<NAME>g_param_spec_object</NAME>
<RETURNS>GParamSpec *</RETURNS>
const gchar    *name,const gchar    *nick,const gchar    *blurb,GType           object_type,GParamFlags     flags
</FUNCTION>
<VARIABLE>
<NAME>g_log_domain_gobject</NAME>
extern const char *g_log_domain_gobject;
</VARIABLE>
<MACRO>
<NAME>G_TYPE_FUNDAMENTAL</NAME>
#define G_TYPE_FUNDAMENTAL(type)                ((type) & 0xff)
</MACRO>
<MACRO>
<NAME>G_TYPE_FUNDAMENTAL_MAX</NAME>
#define	G_TYPE_FUNDAMENTAL_MAX			(0xff)
</MACRO>
<MACRO>
<NAME>G_TYPE_DERIVE_ID</NAME>
#define G_TYPE_DERIVE_ID(ptype, branch_seqno)   (G_TYPE_FUNDAMENTAL (ptype) | ((branch_seqno) << 8))
</MACRO>
<MACRO>
<NAME>G_TYPE_BRANCH_SEQNO</NAME>
#define G_TYPE_BRANCH_SEQNO(type)               ((type) >> 8)
</MACRO>
<MACRO>
<NAME>G_TYPE_FUNDAMENTAL_LAST</NAME>
#define G_TYPE_FUNDAMENTAL_LAST                 ((GType) g_type_fundamental_last ())
</MACRO>
<ENUM>
<NAME>GTypeFundamentals</NAME>
typedef enum    /*< skip >*/
{
  /* standard types, introduced by g_type_init() */
  G_TYPE_INVALID,
  G_TYPE_NONE,
  G_TYPE_INTERFACE,

  /* GLib type ids */
  G_TYPE_CHAR,
  G_TYPE_UCHAR,
  G_TYPE_BOOLEAN,
  G_TYPE_INT,
  G_TYPE_UINT,
  G_TYPE_LONG,
  G_TYPE_ULONG,
  G_TYPE_ENUM,
  G_TYPE_FLAGS,
  G_TYPE_FLOAT,
  G_TYPE_DOUBLE,
  G_TYPE_STRING,
  G_TYPE_PARAM,
  G_TYPE_OBJECT,

  /* the following reserved ids should vanish soon */
  G_TYPE_GTK_BOXED,
  G_TYPE_GTK_POINTER,
  G_TYPE_GTK_SIGNAL,

  /* reserved fundamental type ids,
   * mail gtk-devel-list@redhat.com for reservations
   */
  G_TYPE_BSE_PROCEDURE,
  G_TYPE_BSE_TIME,
  G_TYPE_BSE_NOTE,
  G_TYPE_BSE_DOTS,
  G_TYPE_GLE_GOBJECT,

  G_TYPE_LAST_RESERVED_FUNDAMENTAL,

  /* derived type ids */
  /* FIXME: G_TYPE_PARAM_INTERFACE */
  G_TYPE_PARAM_CHAR             = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 1),
  G_TYPE_PARAM_UCHAR            = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 2),
  G_TYPE_PARAM_BOOLEAN          = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 3),
  G_TYPE_PARAM_INT              = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 4),
  G_TYPE_PARAM_UINT             = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 5),
  G_TYPE_PARAM_LONG             = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 6),
  G_TYPE_PARAM_ULONG            = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 7),
  G_TYPE_PARAM_ENUM             = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 8),
  G_TYPE_PARAM_FLAGS            = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 9),
  G_TYPE_PARAM_FLOAT            = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 10),
  G_TYPE_PARAM_DOUBLE           = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 11),
  G_TYPE_PARAM_STRING           = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 12),
  /* FIXME: G_TYPE_PARAM_PARAM */
  G_TYPE_PARAM_OBJECT           = G_TYPE_DERIVE_ID (G_TYPE_PARAM, 13)
} GTypeFundamentals;
</ENUM>
<MACRO>
<NAME>G_TYPE_IS_INTERFACE</NAME>
#define G_TYPE_IS_INTERFACE(type)               (G_TYPE_FUNDAMENTAL (type) == G_TYPE_INTERFACE)
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_CLASSED</NAME>
#define G_TYPE_IS_CLASSED(type)                 (g_type_check_flags ((type), G_TYPE_FLAG_CLASSED))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_INSTANTIATABLE</NAME>
#define G_TYPE_IS_INSTANTIATABLE(type)          (g_type_check_flags ((type), G_TYPE_FLAG_INSTANTIATABLE))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_DERIVABLE</NAME>
#define G_TYPE_IS_DERIVABLE(type)               (g_type_check_flags ((type), G_TYPE_FLAG_DERIVABLE))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_DEEP_DERIVABLE</NAME>
#define G_TYPE_IS_DEEP_DERIVABLE(type)          (g_type_check_flags ((type), G_TYPE_FLAG_DEEP_DERIVABLE))
</MACRO>
<MACRO>
<NAME>G_TYPE_IS_PARAM</NAME>
#define G_TYPE_IS_PARAM(type)                   (G_TYPE_FUNDAMENTAL (type) == G_TYPE_PARAM)
</MACRO>
<TYPEDEF>
<NAME>GType</NAME>
typedef guint32                         GType;
</TYPEDEF>
<STRUCT>
<NAME>GValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypePlugin</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypePluginVTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypeInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypeInstance</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypeInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypeFundamentalInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GInterfaceInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypeValueTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypeInstance</NAME>
struct GTypeInstance
{
  /*< private >*/
  GTypeClass *g_class;
};
</STRUCT>
<STRUCT>
<NAME>GTypeInterface</NAME>
struct GTypeInterface
{
  /*< private >*/
  GType g_type;         /* iface type */
  GType g_instance_type;
};
</STRUCT>
<MACRO>
<NAME>G_TYPE_CHECK_INSTANCE_CAST</NAME>
#define G_TYPE_CHECK_INSTANCE_CAST(instance, g_type, c_type)    (_G_TYPE_CIC ((instance), (g_type), c_type))
</MACRO>
<MACRO>
<NAME>G_TYPE_CHECK_CLASS_CAST</NAME>
#define G_TYPE_CHECK_CLASS_CAST(g_class, g_type, c_type)        (_G_TYPE_CCC ((g_class), (g_type), c_type))
</MACRO>
<MACRO>
<NAME>G_TYPE_CHECK_INSTANCE_TYPE</NAME>
#define G_TYPE_CHECK_INSTANCE_TYPE(instance, g_type)            (_G_TYPE_CIT ((instance), (g_type)))
</MACRO>
<MACRO>
<NAME>G_TYPE_CHECK_CLASS_TYPE</NAME>
#define G_TYPE_CHECK_CLASS_TYPE(g_class, g_type)                (_G_TYPE_CCT ((g_class), (g_type)))
</MACRO>
<MACRO>
<NAME>G_TYPE_INSTANCE_GET_CLASS</NAME>
#define G_TYPE_INSTANCE_GET_CLASS(instance, g_type, c_type)     (_G_TYPE_IGC ((instance), c_type))
</MACRO>
<MACRO>
<NAME>G_TYPE_FROM_INSTANCE</NAME>
#define G_TYPE_FROM_INSTANCE(instance)                          (G_TYPE_FROM_CLASS (((GTypeInstance*) (instance))->g_class))
</MACRO>
<MACRO>
<NAME>G_TYPE_FROM_CLASS</NAME>
#define G_TYPE_FROM_CLASS(g_class)                              (((GTypeClass*) (g_class))->g_type)
</MACRO>
<MACRO>
<NAME>G_TYPE_FROM_INTERFACE</NAME>
#define G_TYPE_FROM_INTERFACE(g_iface)                          (((GTypeInterface*) (g_iface))->g_type)
</MACRO>
<FUNCTION>
<NAME>g_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_type_name</NAME>
<RETURNS>gchar *</RETURNS>
GType                   type
</FUNCTION>
<FUNCTION>
<NAME>g_type_qname</NAME>
<RETURNS>GQuark  </RETURNS>
GType                   type
</FUNCTION>
<FUNCTION>
<NAME>g_type_from_name</NAME>
<RETURNS>GType  </RETURNS>
const gchar            *name
</FUNCTION>
<FUNCTION>
<NAME>g_type_parent</NAME>
<RETURNS>GType  </RETURNS>
GType                   type
</FUNCTION>
<FUNCTION>
<NAME>g_type_next_base</NAME>
<RETURNS>GType  </RETURNS>
GType                   type,GType                   base_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_is_a</NAME>
<RETURNS>gboolean  </RETURNS>
GType                   type,GType                   is_a_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_conforms_to</NAME>
<RETURNS>gboolean  </RETURNS>
GType                   type,GType                   iface_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_fundamental_branch_last</NAME>
<RETURNS>guint  </RETURNS>
GType                   type
</FUNCTION>
<FUNCTION>
<NAME>g_type_class_ref</NAME>
<RETURNS>gpointer  </RETURNS>
GType                   type
</FUNCTION>
<FUNCTION>
<NAME>g_type_class_peek</NAME>
<RETURNS>gpointer  </RETURNS>
GType                   type
</FUNCTION>
<FUNCTION>
<NAME>g_type_class_unref</NAME>
<RETURNS>void  </RETURNS>
gpointer                g_class
</FUNCTION>
<FUNCTION>
<NAME>g_type_class_peek_parent</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer                g_class
</FUNCTION>
<FUNCTION>
<NAME>g_type_interface_peek</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer                instance_class,GType                   iface_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_children</NAME>
<RETURNS>GType *</RETURNS>
GType                   type,guint                  *n_children
</FUNCTION>
<FUNCTION>
<NAME>g_type_interfaces</NAME>
<RETURNS>GType *</RETURNS>
GType                   type,guint                  *n_interfaces
</FUNCTION>
<FUNCTION>
<NAME>g_type_set_qdata</NAME>
<RETURNS>void  </RETURNS>
GType                   type,GQuark                  quark,gpointer                data
</FUNCTION>
<FUNCTION>
<NAME>g_type_get_qdata</NAME>
<RETURNS>gpointer  </RETURNS>
GType                   type,GQuark                  quark
</FUNCTION>
<USER_FUNCTION>
<NAME>GBaseInitFunc</NAME>
<RETURNS>void </RETURNS>
gpointer         g_class
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GBaseFinalizeFunc</NAME>
<RETURNS>void </RETURNS>
gpointer         g_class
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GClassInitFunc</NAME>
<RETURNS>void </RETURNS>
gpointer         g_class,
					      gpointer         class_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GClassFinalizeFunc</NAME>
<RETURNS>void </RETURNS>
gpointer         g_class,
					      gpointer         class_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GInstanceInitFunc</NAME>
<RETURNS>void </RETURNS>
GTypeInstance   *instance,
					      gpointer         g_class
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GInterfaceInitFunc</NAME>
<RETURNS>void </RETURNS>
gpointer         g_iface,
					      gpointer         iface_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GInterfaceFinalizeFunc</NAME>
<RETURNS>void </RETURNS>
gpointer         g_iface,
					      gpointer         iface_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTypePluginRef</NAME>
<RETURNS>void </RETURNS>
GTypePlugin     *plugin
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTypePluginUnRef</NAME>
<RETURNS>void </RETURNS>
GTypePlugin     *plugin
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTypePluginFillTypeInfo</NAME>
<RETURNS>void </RETURNS>
GTypePlugin     *plugin,
                                              GType            g_type,
                                              GTypeInfo       *info,
					      GTypeValueTable *value_table
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTypePluginFillInterfaceInfo</NAME>
<RETURNS>void </RETURNS>
GTypePlugin     *plugin,
                                              GType            interface_type,
                                              GType            instance_type,
                                              GInterfaceInfo  *info
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GTypeClassCacheFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer	       cache_data,
					      GTypeClass      *g_class
</USER_FUNCTION>
<STRUCT>
<NAME>GTypePlugin</NAME>
struct GTypePlugin
{
  GTypePluginVTable     *vtable;
};
</STRUCT>
<STRUCT>
<NAME>GTypePluginVTable</NAME>
struct GTypePluginVTable
{
  GTypePluginRef                plugin_ref;
  GTypePluginUnRef              plugin_unref;
  GTypePluginFillTypeInfo       complete_type_info;
  GTypePluginFillInterfaceInfo  complete_interface_info;
};
</STRUCT>
<ENUM>
<NAME>GTypeFlags</NAME>
typedef enum    /*< skip >*/
{
  G_TYPE_FLAG_CLASSED           = (1 << 0),
  G_TYPE_FLAG_INSTANTIATABLE    = (1 << 1),
  G_TYPE_FLAG_DERIVABLE         = (1 << 2),
  G_TYPE_FLAG_DEEP_DERIVABLE    = (1 << 3)
} GTypeFlags;
</ENUM>
<STRUCT>
<NAME>GTypeInfo</NAME>
struct GTypeInfo
{
  /* interface types, classed types, instantiated types */
  guint16                class_size;

  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;

  /* classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;

  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;

  /* value handling */
  const GTypeValueTable	*value_table;
};
</STRUCT>
<STRUCT>
<NAME>GTypeFundamentalInfo</NAME>
struct GTypeFundamentalInfo
{
  GTypeFlags             type_flags;
};
</STRUCT>
<STRUCT>
<NAME>GInterfaceInfo</NAME>
struct GInterfaceInfo
{
  GInterfaceInitFunc     interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer               interface_data;
};
</STRUCT>
<STRUCT>
<NAME>GTypeValueTable</NAME>
struct GTypeValueTable
{
  void   (*value_init)    (GValue       *value);
  void   (*value_free)    (GValue       *value);
  void   (*value_copy)    (const GValue *src_value,
			   GValue       *dest_value);
  /* varargs functionality (optional) */
  guint    collect_type;
  gchar* (*collect_value) (GValue       *value,
			   guint         nth_value,
			   GType        *collect_type,
			   GTypeCValue  *collect_value);
  guint    lcopy_type;
  gchar* (*lcopy_value)   (const GValue *value,
			   guint         nth_value,
			   GType        *collect_type,
			   GTypeCValue  *collect_value);
};
</STRUCT>
<FUNCTION>
<NAME>g_type_register_static</NAME>
<RETURNS>GType  </RETURNS>
GType                       parent_type,const gchar                *type_name,const GTypeInfo            *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_register_dynamic</NAME>
<RETURNS>GType  </RETURNS>
GType                       parent_type,const gchar                *type_name,GTypePlugin                *plugin
</FUNCTION>
<FUNCTION>
<NAME>g_type_register_fundamental</NAME>
<RETURNS>GType  </RETURNS>
GType                       type_id,const gchar                *type_name,const GTypeInfo            *info,const GTypeFundamentalInfo *finfo
</FUNCTION>
<FUNCTION>
<NAME>g_type_add_interface_static</NAME>
<RETURNS>void  </RETURNS>
GType                       instance_type,GType                       interface_type,GInterfaceInfo             *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_add_interface_dynamic</NAME>
<RETURNS>void  </RETURNS>
GType                       instance_type,GType                       interface_type,GTypePlugin                *plugin
</FUNCTION>
<FUNCTION>
<NAME>g_type_class_is_a</NAME>
<RETURNS>gboolean  </RETURNS>
GTypeClass         *g_class,GType               is_a_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_check_class_cast</NAME>
<RETURNS>GTypeClass *</RETURNS>
GTypeClass         *g_class,GType               is_a_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_check_instance_cast</NAME>
<RETURNS>GTypeInstance *</RETURNS>
GTypeInstance      *instance,GType               iface_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_instance_conforms_to</NAME>
<RETURNS>gboolean  </RETURNS>
GTypeInstance      *instance,GType               iface_type
</FUNCTION>
<FUNCTION>
<NAME>g_type_check_flags</NAME>
<RETURNS>gboolean  </RETURNS>
GType               type,GTypeFlags          flags
</FUNCTION>
<FUNCTION>
<NAME>g_type_create_instance</NAME>
<RETURNS>GTypeInstance *</RETURNS>
GType               type
</FUNCTION>
<FUNCTION>
<NAME>g_type_free_instance</NAME>
<RETURNS>void  </RETURNS>
GTypeInstance      *instance
</FUNCTION>
<FUNCTION>
<NAME>g_type_value_table_peek</NAME>
<RETURNS>GTypeValueTable *</RETURNS>
GType		     type
</FUNCTION>
<FUNCTION>
<NAME>g_type_add_class_cache_func</NAME>
<RETURNS>void 	</RETURNS>
gpointer	     cache_data,GTypeClassCacheFunc cache_func
</FUNCTION>
<FUNCTION>
<NAME>g_type_remove_class_cache_func</NAME>
<RETURNS>void 	</RETURNS>
gpointer	     cache_data,GTypeClassCacheFunc cache_func
</FUNCTION>
<FUNCTION>
<NAME>g_type_class_unref_uncached</NAME>
<RETURNS>void  </RETURNS>
gpointer            g_class
</FUNCTION>
<FUNCTION>
<NAME>g_type_get_plugin</NAME>
<RETURNS>GTypePlugin *</RETURNS>
GType		     type
</FUNCTION>
<FUNCTION>
<NAME>g_type_fundamental_last</NAME>
<RETURNS>GType 	</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IS_VALUE</NAME>
#define	G_TYPE_IS_VALUE(type)		(g_type_value_table_peek (type) != NULL)
</MACRO>
<MACRO>
<NAME>G_IS_VALUE</NAME>
#define	G_IS_VALUE(value)		(G_TYPE_IS_VALUE (G_VALUE_TYPE (value))) /* FIXME */
</MACRO>
<MACRO>
<NAME>G_VALUE_TYPE</NAME>
#define	G_VALUE_TYPE(value)		(G_TYPE_FROM_CLASS (value))
</MACRO>
<MACRO>
<NAME>G_VALUE_TYPE_NAME</NAME>
#define	G_VALUE_TYPE_NAME(value)	(g_type_name (G_VALUE_TYPE (value)))
</MACRO>
<USER_FUNCTION>
<NAME>GValueExchange</NAME>
<RETURNS>void </RETURNS>
GValue	*value1,
				GValue	*value2
</USER_FUNCTION>
<STRUCT>
<NAME>GValue</NAME>
struct GValue
{
  /*< private >*/
  GType		g_type;

  /* public for GTypeValueTable methods */
  union {
    gint	v_int;
    guint	v_uint;
    glong	v_long;
    gulong	v_ulong;
    gfloat	v_float;
    gdouble	v_double;
    gpointer	v_pointer;
  } data[4];
};
</STRUCT>
<FUNCTION>
<NAME>g_value_init</NAME>
<RETURNS>void  </RETURNS>
GValue       *value,GType         g_type
</FUNCTION>
<FUNCTION>
<NAME>g_value_copy</NAME>
<RETURNS>void  </RETURNS>
const GValue *src_value,GValue       *dest_value
</FUNCTION>
<FUNCTION>
<NAME>g_value_convert</NAME>
<RETURNS>gboolean 	</RETURNS>
const GValue *src_value,GValue       *dest_value
</FUNCTION>
<FUNCTION>
<NAME>g_value_reset</NAME>
<RETURNS>void  </RETURNS>
GValue       *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_unset</NAME>
<RETURNS>void  </RETURNS>
GValue       *value
</FUNCTION>
<FUNCTION>
<NAME>g_values_exchange</NAME>
<RETURNS>gboolean  </RETURNS>
GValue       *value1,GValue       *value2
</FUNCTION>
<FUNCTION>
<NAME>g_value_types_exchangable</NAME>
<RETURNS>gboolean  </RETURNS>
GType         value_type1,GType         value_type2
</FUNCTION>
<FUNCTION>
<NAME>g_value_register_exchange_func</NAME>
<RETURNS>void  </RETURNS>
GType         value_type1,GType         value_type2,GValueExchange func
</FUNCTION>
<UNION>
<NAME>GTypeCValue</NAME>
union GTypeCValue
{
  gint     v_int;
  glong    v_long;
  gdouble  v_double;
  gpointer v_pointer;
};
</UNION>
<MACRO>
<NAME>G_VALUE_COLLECT</NAME>
#define G_VALUE_COLLECT(value, var_args, __error)					\
G_STMT_START {										\
  GValue *_value = (value);								\
  GTypeValueTable *_vtable = g_type_value_table_peek (G_VALUE_TYPE (_value));		\
  gchar *_error_msg = NULL;								\
  guint _collect_type = _vtable->collect_type;						\
  guint _nth_value = 0;									\
                                                                                        \
  g_value_reset (_value);								\
  while (_collect_type && !_error_msg)							\
    {											\
      GTypeCValue _cvalue;								\
                                                                                        \
      memset (&_cvalue, 0, sizeof (_cvalue));						\
      switch (_collect_type)								\
	{										\
	case G_VALUE_COLLECT_INT:							\
	  _cvalue.v_int = va_arg ((var_args), gint);					\
	  break;									\
	case G_VALUE_COLLECT_LONG:							\
	  _cvalue.v_long = va_arg ((var_args), glong);					\
	  break;									\
	case G_VALUE_COLLECT_DOUBLE:							\
	  _cvalue.v_double = va_arg ((var_args), gdouble);				\
	  break;									\
	case G_VALUE_COLLECT_POINTER:							\
	  _cvalue.v_pointer = va_arg ((var_args), gpointer);				\
	  break;									\
	default:									\
	  _error_msg  = g_strdup_printf ("%s: invalid collect type (%d) used for %s",	\
					 G_STRLOC,					\
					 _collect_type,					\
					 "G_VALUE_COLLECT()");				\
	  continue;									\
	}										\
      _error_msg = _vtable->collect_value (_value,					\
					   _nth_value++,				\
					   &_collect_type,				\
					   &_cvalue);					\
    }											\
  *(__error) = _error_msg;								\
} G_STMT_END
</MACRO>
<MACRO>
<NAME>G_VALUE_LCOPY</NAME>
#define G_VALUE_LCOPY(value, var_args, __error)						\
G_STMT_START {										\
  GValue *_value = (value);								\
  GTypeValueTable *_vtable = g_type_value_table_peek (G_VALUE_TYPE (_value));		\
  gchar *_error_msg = NULL;								\
  guint _lcopy_type = _vtable->lcopy_type;						\
  guint _nth_value = 0;									\
                                                                                        \
  while (_lcopy_type && !_error_msg)							\
    {											\
      GTypeCValue _cvalue;								\
                                                                                        \
      memset (&_cvalue, 0, sizeof (_cvalue));						\
      switch (_lcopy_type)								\
	{										\
	case G_VALUE_COLLECT_INT:							\
	  _cvalue.v_int = va_arg ((var_args), gint);					\
	  break;									\
	case G_VALUE_COLLECT_LONG:							\
	  _cvalue.v_long = va_arg ((var_args), glong);					\
	  break;									\
	case G_VALUE_COLLECT_DOUBLE:							\
	  _cvalue.v_double = va_arg ((var_args), gdouble);				\
	  break;									\
	case G_VALUE_COLLECT_POINTER:							\
	  _cvalue.v_pointer = va_arg ((var_args), gpointer);				\
	  break;									\
	default:									\
	  _error_msg  = g_strdup_printf ("%s: invalid collect type (%d) used for %s",	\
					 G_STRLOC,					\
					 _lcopy_type,					\
					 "G_VALUE_LCOPY()");				\
	  continue;									\
	}										\
      _error_msg = _vtable->lcopy_value (_value,					\
					 _nth_value++,					\
					 &_lcopy_type,					\
					 &_cvalue);					\
    }											\
  *(__error) = _error_msg;								\
} G_STMT_END
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_CHAR</NAME>
#define G_IS_VALUE_CHAR(value)          (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_CHAR))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_UCHAR</NAME>
#define G_IS_VALUE_UCHAR(value)         (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_UCHAR))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_BOOLEAN</NAME>
#define G_IS_VALUE_BOOLEAN(value)       (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_BOOLEAN))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_INT</NAME>
#define G_IS_VALUE_INT(value)           (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_INT))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_UINT</NAME>
#define G_IS_VALUE_UINT(value)          (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_UINT))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_LONG</NAME>
#define G_IS_VALUE_LONG(value)          (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_LONG))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_ULONG</NAME>
#define G_IS_VALUE_ULONG(value)         (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_ULONG))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_FLOAT</NAME>
#define G_IS_VALUE_FLOAT(value)         (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_FLOAT))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_DOUBLE</NAME>
#define G_IS_VALUE_DOUBLE(value)        (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_DOUBLE))
</MACRO>
<MACRO>
<NAME>G_IS_VALUE_STRING</NAME>
#define G_IS_VALUE_STRING(value)        (G_TYPE_CHECK_CLASS_TYPE ((value), G_TYPE_STRING))
</MACRO>
<FUNCTION>
<NAME>g_value_set_char</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,gint8           v_char
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_char</NAME>
<RETURNS>gint8  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_uchar</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,guint8          v_uchar
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_uchar</NAME>
<RETURNS>guint8  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_boolean</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,gboolean        v_boolean
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_boolean</NAME>
<RETURNS>gboolean  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_int</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,gint            v_int
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_int</NAME>
<RETURNS>gint  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_uint</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,guint           v_uint
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_uint</NAME>
<RETURNS>guint  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_long</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,glong           v_long
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_long</NAME>
<RETURNS>glong  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_ulong</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,gulong          v_ulong
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_ulong</NAME>
<RETURNS>gulong  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_float</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,gfloat          v_float
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_float</NAME>
<RETURNS>gfloat  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_double</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,gdouble         v_double
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_double</NAME>
<RETURNS>gdouble  </RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_set_string</NAME>
<RETURNS>void  </RETURNS>
GValue         *value,const gchar    *v_string
</FUNCTION>
<FUNCTION>
<NAME>g_value_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GValue         *value
</FUNCTION>
<FUNCTION>
<NAME>g_value_dup_string</NAME>
<RETURNS>gchar *</RETURNS>
GValue         *value
</FUNCTION>
