<!-- ##### SECTION Title ##### -->
Signals

<!-- ##### SECTION Short_Description ##### -->
A means for customization of object behaviour and a general purpose notification mechanism

<!-- ##### SECTION Long_Description ##### -->
<para>
The basic concept of the signal system is that of the <emphasis>emission</emphasis>
of a signal.
Signals are introduced per-type and are identified through strings.
Signals introduced for a parent type are available in derived types as well,
so basically they are a per-type facility that is inherited.
A signal emission mainly involves invocation of a certain set of callbacks in
precisely defined manner. There are two main categories of such callbacks,
per-object
	<footnote><para>Although signals can deal with any kind of instantiatable type,
	i'm referring to those types as "object types" in the following, simply
	because that is the context most users will encounter signals in.
	</para></footnote>
ones and user provided ones.
The per-object callbacks are most often referred to as "object method
handler" or "default (signal) handler", while user provided callbacks are
usually just called "signal handler".
The object method handler is provided at signal creation time (this most
frequently happens at the end of an object class' creation), while user
provided handlers are frequently connected and disconnected to/from a certain
signal on certain object instances.
</para>
<para>
A signal emission consists of five stages, unless prematurely stopped:
<variablelist>
  <varlistentry><term></term><listitem><para>
	1 - Invocation of the object method handler for %G_SIGNAL_RUN_FIRST signals
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	2 - Invocation of normal user-provided signal handlers (<emphasis>after</emphasis> flag %FALSE)
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	3 - Invocation of the object method handler for %G_SIGNAL_RUN_LAST signals
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	4 - Invocation of user provided signal handlers, connected with an <emphasis>after</emphasis> flag of %TRUE
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	5 - Invocation of the object method handler for %G_SIGNAL_RUN_CLEANUP signals
  </para></listitem></varlistentry>
</variablelist>
The user provided signal handlers are called in the order they were
connected in.
All handlers may prematurely stop a signal emission, and any number of
handlers may be connected, disconnected, blocked or unblocked during
a signal emission.
There are certain criteria for skipping user handlers in stages 2 and 4
of a signal emission.
First, user handlers may be <emphasis>blocked</emphasis>, blocked handlers are omitted
during callback invocation, to return from the "blocked" state, a
handler has to get unblocked exactly the same amount of times
it has been blocked before.
Second, upon emission of a %G_SIGNAL_DETAILED signal, an additional
"detail" argument passed in to g_signal_emit() has to match the detail
argument of the signal handler currently subject to invocation.
Specification of no detail argument for signal handlers (omission of the
detail part of the signal specification upon connection) serves as a
wildcard and matches any detail argument passed in to emission.
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### STRUCT GSignalInvocationHint ##### -->
<para>
The #GSignalInvocationHint structure is used to pass on additional information
to callbacks during a signal emission.
</para>

@signal_id: 	The signal id of the signal invoking the callback
@detail: 	The detail passed on for this emission
@run_type: 	The stage the signal emission is currently in, this
		field will contain one of %G_SIGNAL_RUN_FIRST,
		%G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP.

<!-- ##### USER_FUNCTION GSignalAccumulator ##### -->
<para>
The signal accumulator is a special callback function that can be used
to collect return values of the various callbacks that are called
during a signal emission. The signal accumulator is specified at signal
creation time, if it is left NULL, no accumulation of callback return
values is performed. The return value of signal emissions is then the
value returned by the last callback.
</para>

@ihint: 	Signal invocation hint, see #GSignalInvocationHint.
@return_accu: 	Accumulator to collect callback return values in, this
		is the return value of the current signal emission.
@handler_return: 
@data: 
@Returns: 	The accumulator function returns whether the signal emission
		should be aborted. Returning %FALSE means to abort the
		current emission and %TRUE is returned for continuation.
<!-- # Unused Parameters # -->
@return_value: 	The return value of the most recent callback function.


<!-- ##### TYPEDEF GSignalCMarshaller ##### -->
<para>
This is the signature of marshaller functions, required to marshall
arrays of parameter values to signal emissions into C language callback
invocations. It is merely an alias to #GClosureMarshal since the #GClosure
mechanism takes over responsibility of actual function invocation for the
signal system.
</para>


<!-- ##### USER_FUNCTION GSignalEmissionHook ##### -->
<para>
A simple function pointer to get invoked when the signal is emitted. This 
allows you tie a hook to the signal type, so that it will trap all emissions 
of that signal, from any object.
</para>
<para>
You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag.
</para>

@ihint: Signal invocation hint, see #GSignalInvocationHint.
@n_param_values: the number of parameters to the function, including
                 the instance on which the signal was emitted.
@param_values: the instance on which the signal was emitted, followed by the 
               parameters of the emission.
@data: user data associated with the hook.
@Returns: whether it wished to be removed. If it returns %TRUE, the signal 
          hook is disconnected (and destroyed).


<!-- ##### ENUM GSignalFlags ##### -->
<para>
The signal flags are used to specify a signal's behaviour, the overall
signal description outlines how especially the RUN flags control the
stages of a signal emission.
</para>

@G_SIGNAL_RUN_FIRST:   Invoke the object method handler in the first emission stage.
@G_SIGNAL_RUN_LAST:    Invoke the object method handler in the third emission stage.
@G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.
@G_SIGNAL_NO_RECURSE:  Signals being emitted for an object while currently being in
                       emission for this very object will not be emitted recursively,
                       but instead cause the first emission to be restarted.
@G_SIGNAL_DETAILED:    This signal supports "::detail" appendixes to the signal name
                       upon handler connections and emissions.
@G_SIGNAL_ACTION:      Action signals are signals that may freely be emitted on alive
                       objects from user code via g_signal_emit() and friends, without
                       the need of being embedded into extra code that performs pre or
                       post emission adjustments on the object. They can also be thought
                       of as by third-party code generically callable object methods.
@G_SIGNAL_NO_HOOKS:    No emissions hooks are supported for this signal.

<!-- ##### ENUM GSignalMatchType ##### -->
<para>
The match types specify what g_signal_handlers_block_matched(),
g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
match signals by.
</para>

@G_SIGNAL_MATCH_ID: The signal id must be equal.
@G_SIGNAL_MATCH_DETAIL: The signal detail be equal.
@G_SIGNAL_MATCH_CLOSURE: The closure must be the same.
@G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.
@G_SIGNAL_MATCH_DATA: The closure data must be the same.
@G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may matched.

<!-- ##### STRUCT GSignalQuery ##### -->
<para>
A structure holding in-depth information for a specific signal. It is
filled in by the g_signal_query() function.
</para>

@signal_id: 	The signal id of the signal being queried, or 0 if the
		signal to be queried was unknown.
@signal_name: 	The signal name.
@itype: 	The interface/instance type that this signal can be emitted for.
@signal_flags: 	The signal flags as passed in to g_signal_new().
@return_type: 	The return type for user callbacks.
@n_params: 	The number of parameters that user callbacks take.
@param_types: 	The individual parameter types for user callbacks, note that the
		effective callback signature is:
<programlisting>
@return_type callback (#gpointer     data1,
                      [#param_types param_names,]
                       #gpointer     data2);
</programlisting>

<!-- ##### MACRO G_SIGNAL_TYPE_STATIC_SCOPE ##### -->
<para>
This macro flags signal argument types for which the signal system may 
assume that instances thereof remain persistent across all signal emissions
they are used in. This is only useful for non ref-counted, value-copy types.
</para>
<para>
To flag a signal argument in this way, add 
<literal>| G_SIGNAL_TYPE_STATIC_SCOPE</literal> to the corresponding argument
of g_signal_new().
</para>
<informalexample>
<programlisting>
    g_signal_new ("size_request",
		  G_TYPE_FROM_CLASS (gobject_class),
		  G_SIGNAL_RUN_FIRST,
		  G_STRUCT_OFFSET (GtkWidgetClass, size_request),
		  NULL, NULL,
		  _gtk_marshal_VOID__BOXED,
		  G_TYPE_NONE, 1,
		  GTK_TYPE_REQUISITION | G_SIGNAL_TYPE_STATIC_SCOPE);
</programlisting>
</informalexample>



<!-- ##### MACRO G_SIGNAL_MATCH_MASK ##### -->
<para>

</para>



<!-- ##### MACRO G_SIGNAL_FLAGS_MASK ##### -->
<para>

</para>



<!-- ##### FUNCTION g_signal_new ##### -->
<para>

</para>

@signal_name: 
@itype: 
@signal_flags: 
@class_offset: 
@accumulator: 
@accu_data: 
@c_marshaller: 
@return_type: 
@n_params: 
@Varargs: 
@Returns: 


<!-- ##### FUNCTION g_signal_newv ##### -->
<para>

</para>

@signal_name: 
@itype: 
@signal_flags: 
@class_closure: 
@accumulator: 
@accu_data: 
@c_marshaller: 
@return_type: 
@n_params: 
@param_types: 
@Returns: 


<!-- ##### FUNCTION g_signal_new_valist ##### -->
<para>

</para>

@signal_name: 
@itype: 
@signal_flags: 
@class_closure: 
@accumulator: 
@accu_data: 
@c_marshaller: 
@return_type: 
@n_params: 
@args: 
@Returns: 


<!-- ##### FUNCTION g_signal_query ##### -->
<para>
</para>

@signal_id: 
@query: 


<!-- ##### FUNCTION g_signal_lookup ##### -->
<para>

</para>

@name: 
@itype: 
@Returns: 


<!-- ##### FUNCTION g_signal_name ##### -->
<para>

</para>

@signal_id: 
@Returns: 


<!-- ##### FUNCTION g_signal_list_ids ##### -->
<para>
</para>

@itype: 
@n_ids: 
@Returns: 


<!-- ##### FUNCTION g_signal_emit ##### -->
<para>

</para>

@instance: 
@signal_id: 
@detail: 
@Varargs: 


<!-- ##### FUNCTION g_signal_emit_by_name ##### -->
<para>

</para>

@instance: 
@detailed_signal: 
@Varargs: 


<!-- ##### FUNCTION g_signal_emitv ##### -->
<para>

</para>

@instance_and_params: 
@signal_id: 
@detail: 
@return_value: 


<!-- ##### FUNCTION g_signal_emit_valist ##### -->
<para>

</para>

@instance: 
@signal_id: 
@detail: 
@var_args: 


<!-- ##### MACRO g_signal_connect ##### -->
<para>
Connects a #GCallback function to a signal for a particular object.
</para>
<para>
The handler will be called before the default handler of the signal.
</para>

@instance: the instance to connect to.
@detailed_signal: a string of the form "signal-name::detail".
@c_handler: the #GCallback to connect.
@data: data to pass to @c_handler calls.
@Returns: the handler id


<!-- ##### MACRO g_signal_connect_after ##### -->
<para>
Connects a #GCallback function to a signal for a particular object.
</para>
<para>
The handler will be called after the default handler of the signal.
</para>

@instance: the instance to connect to.
@detailed_signal: a string of the form "signal-name::detail".
@c_handler: the #GCallback to connect.
@data: data to pass to @c_handler calls.
@Returns: the handler id


<!-- ##### MACRO g_signal_connect_swapped ##### -->
<para>
Connects a #GCallback function to a signal for a particular object.
</para>
<para>
The instance on which the signal is emitted and @data will be swapped when 
calling the handler.
</para>

@instance: the instance to connect to.
@detailed_signal: a string of the form "signal-name::detail".
@c_handler: the #GCallback to connect.
@data: data to pass to @c_handler calls.
@Returns: the handler id


<!-- ##### FUNCTION g_signal_connect_object ##### -->
<para>

</para>

@instance: 
@detailed_signal: 
@c_handler: 
@gobject: 
@connect_flags: 
@Returns: 


<!-- ##### ENUM GConnectFlags ##### -->
<para>
The connection flags are used to specify the behaviour of a signal's 
connection.
</para>

@G_CONNECT_AFTER: whether the handler should be called before or after the 
                  default handler of the signal.
@G_CONNECT_SWAPPED: whether the instance and data should be swapped when
                  calling the handler.

<!-- ##### FUNCTION g_signal_connect_data ##### -->
<para>

</para>

@instance: 
@detailed_signal: 
@c_handler: 
@data: 
@destroy_data: 
@connect_flags: 
@Returns: 


<!-- ##### FUNCTION g_signal_connect_closure ##### -->
<para>

</para>

@instance: 
@detailed_signal: 
@closure: 
@after: 
@Returns: 


<!-- ##### FUNCTION g_signal_connect_closure_by_id ##### -->
<para>

</para>

@instance: 
@signal_id: 
@detail: 
@closure: 
@after: 
@Returns: 


<!-- ##### FUNCTION g_signal_handler_block ##### -->
<para>
</para>

@instance: 
@handler_id: 


<!-- ##### FUNCTION g_signal_handler_unblock ##### -->
<para>
</para>

@instance: 
@handler_id: 


<!-- ##### FUNCTION g_signal_handler_disconnect ##### -->
<para>
</para>

@instance: 
@handler_id: 


<!-- ##### FUNCTION g_signal_handler_find ##### -->
<para>
</para>

@instance: 
@mask: 
@signal_id: 
@detail: 
@closure: 
@func: 
@data: 
@Returns: 


<!-- ##### FUNCTION g_signal_handlers_block_matched ##### -->
<para>
</para>

@instance: 
@mask: 
@signal_id: 
@detail: 
@closure: 
@func: 
@data: 
@Returns: 


<!-- ##### FUNCTION g_signal_handlers_unblock_matched ##### -->
<para>
</para>

@instance: 
@mask: 
@signal_id: 
@detail: 
@closure: 
@func: 
@data: 
@Returns: 


<!-- ##### FUNCTION g_signal_handlers_disconnect_matched ##### -->
<para>
</para>

@instance: 
@mask: 
@signal_id: 
@detail: 
@closure: 
@func: 
@data: 
@Returns: 


<!-- ##### FUNCTION g_signal_handler_is_connected ##### -->
<para>

</para>

@instance: 
@handler_id: 
@Returns: 


<!-- ##### MACRO g_signal_handlers_block_by_func ##### -->
<para>
Blocks all handlers on an instance that match @func and @data.
</para>

@instance: The instance to block handlers from.
@func: The C closure callback of the handlers (useless for non-C closures).
@data: The closure data of the handlers' closures.
@Returns: The number of handlers that got blocked.


<!-- ##### MACRO g_signal_handlers_unblock_by_func ##### -->
<para>
Unblocks all handlers on an instance that match @func and @data.
</para>

@instance: The instance to unblock handlers from.
@func: The C closure callback of the handlers (useless for non-C closures).
@data: The closure data of the handlers' closures.
@Returns: The number of handlers that got unblocked.


<!-- ##### MACRO g_signal_handlers_disconnect_by_func ##### -->
<para>
Disconnects all handlers on an instance that match @func and @data.
</para>

@instance: The instance to remove handlers from.
@func: The C closure callback of the handlers (useless for non-C closures).
@data: The closure data of the handlers' closures.
@Returns: The number of handlers that got disconnected.


<!-- ##### FUNCTION g_signal_has_handler_pending ##### -->
<para>

</para>

@instance: 
@signal_id: 
@detail: 
@may_be_blocked: 
@Returns: 


<!-- ##### FUNCTION g_signal_stop_emission ##### -->
<para>

</para>

@instance: 
@signal_id: 
@detail: 


<!-- ##### FUNCTION g_signal_stop_emission_by_name ##### -->
<para>

</para>

@instance: 
@detailed_signal: 


<!-- ##### FUNCTION g_signal_override_class_closure ##### -->
<para>

</para>

@signal_id: 
@instance_type: 
@class_closure: 


<!-- ##### FUNCTION g_signal_chain_from_overridden ##### -->
<para>

</para>

@instance_and_params: 
@return_value: 


<!-- ##### FUNCTION g_signal_add_emission_hook ##### -->
<para>

</para>

@signal_id: 
@detail: 
@hook_func: 
@hook_data: 
@data_destroy: 
@Returns: 
<!-- # Unused Parameters # -->
@quark: 


<!-- ##### FUNCTION g_signal_remove_emission_hook ##### -->
<para>

</para>

@signal_id: 
@hook_id: 


<!-- ##### FUNCTION g_signal_parse_name ##### -->
<para>
</para>

@detailed_signal: 
@itype: 
@signal_id_p: 
@detail_p: 
@force_detail_quark: 
@Returns: 


<!-- ##### FUNCTION g_signal_get_invocation_hint ##### -->
<para>

</para>

@instance: 
@Returns: 


<!-- ##### FUNCTION g_signal_type_cclosure_new ##### -->
<para>

</para>

@itype: 
@struct_offset: 
@Returns: 


