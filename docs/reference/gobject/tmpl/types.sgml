<!-- ##### SECTION Title ##### -->
GType

<!-- ##### SECTION Short_Description ##### -->
The GLib Runtime type identification and management system

<!-- ##### SECTION Long_Description ##### -->
<para>
The GType API is the foundation of the GObject system.  It provides the
facilities for registering and managing all fundamental data types,
user-defined object and interface types.  Before using any GType
or GObject functions, g_type_init() must be called to initialize the
type system.
</para>
<para>
For type creation and registration purposes, all types fall into one of
two categories: static or dynamic.  Static types are never loaded or
unloaded at run-time as dynamic types may be.  Static types are created
with g_type_register_static() that gets type specific information passed
in via a #GTypeInfo structure.
Dynamic types are created with g_type_register_dynamic() which takes a
#GTypePlugin structure instead. The remaining type information (the
#GTypeInfo structure) is retrived during runtime through #GTypePlugin
and the g_type_plugin_*() API.
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### TYPEDEF GType ##### -->
<para>
A numerical value which represents the unique identifier of a registered
type.
</para>


<!-- ##### MACRO G_TYPE_FUNDAMENTAL ##### -->
<para>
Returns #TRUE if @type is a fundamental data type such as #G_TYPE_INT or
#G_TYPE_POINTER. Fundamental types are types that serve as fundaments for
the derived types, thus they are the roots of distinct inheritance heirachies.
</para>

@type: a #GType value


<!-- ##### MACRO G_TYPE_FUNDAMENTAL_MAX ##### -->
<para>
An integer constant that represents the number of identifiers reserved
for types that are assigned at compile-time.
</para>



<!-- ##### MACRO G_TYPE_DERIVE_ID ##### -->
<para>

</para>

@ptype: 
@branch_seqno: 


<!-- ##### MACRO G_TYPE_BRANCH_SEQNO ##### -->
<para>

</para>

@type: 


<!-- ##### MACRO G_TYPE_FUNDAMENTAL_LAST ##### -->
<para>
An integer that currently represents the highest value of all
fundamental type identifiers. This is of interest for dynamic
introduction of new fundamental types (a
<emphasis>rarely</emphasis> needed feature).
</para>



<!-- ##### MACRO G_TYPE_IS_ABSTRACT ##### -->
<para>
Returns #TRUE if @type is an abstract type.  An abstract type can not be
instantiated and is normally used as an abstract base class for
derived classes.
</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_DERIVED ##### -->
<para>
Returns #TRUE if @type is derived (or in object-oriented terminolgy:
inherited) from another type (this holds true for all non-fundamental
types).
</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_FUNDAMENTAL ##### -->
<para>

</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_VALUE_TYPE ##### -->
<para>

</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_CLASSED ##### -->
<para>

</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_INSTANTIATABLE ##### -->
<para>
Returns #TRUE if @type can be instantiated.  Instantiation is the
process of creating an instance (object) of this type.
</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_DERIVABLE ##### -->
<para>

</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_DEEP_DERIVABLE ##### -->
<para>

</para>

@type: A #GType value.


<!-- ##### MACRO G_TYPE_IS_INTERFACE ##### -->
<para>
Returns #TRUE if @type is an interface type.
Interface types are types that provide pure APIs, the implementation
of which is provided by another type (which is then said to conform
to the interface).
</para>

@type: A #GType value.


<!-- ##### ENUM GTypeFundamentals ##### -->
<para>

</para>

@G_TYPE_INVALID: 
@G_TYPE_NONE: 
@G_TYPE_INTERFACE: 
@G_TYPE_CHAR: 
@G_TYPE_UCHAR: 
@G_TYPE_BOOLEAN: 
@G_TYPE_INT: 
@G_TYPE_UINT: 
@G_TYPE_LONG: 
@G_TYPE_ULONG: 
@G_TYPE_ENUM: 
@G_TYPE_FLAGS: 
@G_TYPE_FLOAT: 
@G_TYPE_DOUBLE: 
@G_TYPE_STRING: 
@G_TYPE_PARAM: 
@G_TYPE_BOXED: 
@G_TYPE_POINTER: 
@G_TYPE_CCALLBACK: 
@G_TYPE_OBJECT: 
@G_TYPE_GTK_SIGNAL: 
@G_TYPE_BSE_PROCEDURE: 
@G_TYPE_BSE_TIME: 
@G_TYPE_BSE_NOTE: 
@G_TYPE_BSE_DOTS: 
@G_TYPE_GLE_GOBJECT: 
@G_TYPE_LAST_RESERVED_FUNDAMENTAL: 
@G_TYPE_PARAM_CHAR: 
@G_TYPE_PARAM_UCHAR: 
@G_TYPE_PARAM_BOOLEAN: 
@G_TYPE_PARAM_INT: 
@G_TYPE_PARAM_UINT: 
@G_TYPE_PARAM_LONG: 
@G_TYPE_PARAM_ULONG: 
@G_TYPE_PARAM_ENUM: 
@G_TYPE_PARAM_FLAGS: 
@G_TYPE_PARAM_FLOAT: 
@G_TYPE_PARAM_DOUBLE: 
@G_TYPE_PARAM_STRING: 
@G_TYPE_PARAM_PARAM: 
@G_TYPE_PARAM_POINTER: 
@G_TYPE_PARAM_CCALLBACK: 
@G_TYPE_PARAM_BOXED: 
@G_TYPE_PARAM_OBJECT: 

<!-- ##### STRUCT GTypeInterface ##### -->
<para>

</para>


<!-- ##### STRUCT GTypeInstance ##### -->
<para>

</para>


<!-- ##### STRUCT GTypeInfo ##### -->
<para>
This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a type's class and
instances thereof.
The initialized structure is passed to the g_type_register_static() function
(or is copied into the provided #GTypeInfo structure in the
g_type_plugin_complete_type_info()). The type system will perform a deep
copy of this structure, so it's memory does not need to be persistent
across invocation of g_type_register_static().
</para>

@class_size: 	 Size of the class structure (required for interface, classed and instantiatable types).
@base_init: 	 Location of the base initialization function (optional).
@base_finalize: 	 Location of the base finalization function (optional).
@class_init: 	 Location of the class initialization function (optional, for classed and instantiatable types only).
@class_finalize: Location of the class finalization function (optional).
@class_data: 	 User-supplied data passed to the class init/finalize functions.
@instance_size: 	 Size of the instance (object) structure (required for instantiatable types only).
@n_preallocs: 	 Number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching).
@instance_init: 	 The location of the instance initialization function (optional, for instantiatable types only).
@value_table: 	 Function table for generic handling of GValues of this type (usualy only usefull for
		 fundamental types).

<!-- ##### STRUCT GTypeFundamentalInfo ##### -->
<para>

</para>

@type_flags: 

<!-- ##### STRUCT GInterfaceInfo ##### -->
<para>

</para>

@interface_init: 
@interface_finalize: 
@interface_data: 

<!-- ##### STRUCT GTypeValueTable ##### -->
<para>

</para>

@value_init: 
@value_free: 
@value_copy: 
@value_peek_pointer: 
@collect_type: 
@collect_value: 
@lcopy_type: 
@lcopy_value: 

<!-- ##### MACRO G_TYPE_FROM_INSTANCE ##### -->
<para>

</para>

@instance: 


<!-- ##### MACRO G_TYPE_FROM_CLASS ##### -->
<para>

</para>

@g_class: 


<!-- ##### MACRO G_TYPE_FROM_INTERFACE ##### -->
<para>

</para>

@g_iface: 


<!-- ##### MACRO G_TYPE_INSTANCE_GET_CLASS ##### -->
<para>

</para>

@instance: 
@g_type: 
@c_type: 


<!-- ##### MACRO G_TYPE_INSTANCE_GET_INTERFACE ##### -->
<para>

</para>

@instance: 
@g_type: 
@c_type: 


<!-- ##### MACRO G_TYPE_CHECK_INSTANCE ##### -->
<para>

</para>

@instance: 


<!-- ##### MACRO G_TYPE_CHECK_INSTANCE_CAST ##### -->
<para>

</para>

@instance: 
@g_type: 
@c_type: 


<!-- ##### MACRO G_TYPE_CHECK_INSTANCE_TYPE ##### -->
<para>

</para>

@instance: 
@g_type: 


<!-- ##### MACRO G_TYPE_CHECK_CLASS_CAST ##### -->
<para>

</para>

@g_class: 
@g_type: 
@c_type: 


<!-- ##### MACRO G_TYPE_CHECK_CLASS_TYPE ##### -->
<para>

</para>

@g_class: 
@g_type: 


<!-- ##### MACRO G_TYPE_CHECK_VALUE ##### -->
<para>

</para>

@value: 


<!-- ##### MACRO G_TYPE_CHECK_VALUE_TYPE ##### -->
<para>

</para>

@value: 
@g_type: 


<!-- ##### MACRO G_TYPE_FLAG_RESERVED_ID_BIT ##### -->
<para>

</para>



<!-- ##### FUNCTION g_type_init ##### -->
<para>
Prior to any use of the type system, g_type_init() has to be called to initialize
the type system and assorted other code portions (such as the various fundamental
type implementations or the signal system).
</para>



<!-- ##### FUNCTION g_type_name ##### -->
<para>
Return the unique name that is assigned to a type ID (this is the preferred method
to find out whether a specific type has been registered for the passed in ID yet).
</para>

@type:    Type to return name for.
@Returns: Static type name or NULL.


<!-- ##### FUNCTION g_type_qname ##### -->
<para>
Return the corresponding quark of the type IDs name.
</para>

@type:    Type to return quark of type name for.
@Returns: The type names quark or 0.


<!-- ##### FUNCTION g_type_from_name ##### -->
<para>
Lookup the type ID from a given type name, returns 0 if no type has been registered under this name
(this is the preferred method to find out by name whether a specific type has been registered yet).
</para>

@name:    Type name to lookup.
@Returns: Corresponding type ID or 0.


<!-- ##### FUNCTION g_type_parent ##### -->
<para>
Return the direct parent type of the passed in type.
If the passed in type has no parent, i.e. is a fundamental type, 0 is returned.
</para>

@type:    The derived type.
@Returns: The parent type.


<!-- ##### FUNCTION g_type_next_base ##### -->
<para>
Given a @type and a @base_type which is contained in its anchestry, return
the type that @base_type is the direct parent type for.
In other words, for a given type branch, e.g. Root-Derived1-Derived2-Leaf, specified
through @type=Leaf, return the nextmost child of @base_type. In this example, for
@base_type=Derived1, the returned value would be Derived2, for @base_type=Root, the
returned value would be Derived1.
</para>

@type:      Descendant of @base_type and the type to be returned.
@base_type: Direct parent of the returned type.
@Returns:   Immediate child of @base_type and anchestor of @type.


<!-- ##### FUNCTION g_type_is_a ##### -->
<para>
Check whether @type is a descendant of @is_a_type.
</para>

@type:      Type to check anchestry for.
@is_a_type: Possible anchestor of @type.
@Returns:   %TRUE if @type is_a @is_a_type holds true.


<!-- ##### FUNCTION g_type_fundamental_branch_last ##### -->
<para>

</para>

@type: 
@Returns: 


<!-- ##### FUNCTION g_type_class_ref ##### -->
<para>

</para>

@type: 
@Returns: 


<!-- ##### FUNCTION g_type_class_peek ##### -->
<para>

</para>

@type: 
@Returns: 


<!-- ##### FUNCTION g_type_class_unref ##### -->
<para>

</para>

@g_class: 


<!-- ##### FUNCTION g_type_class_peek_parent ##### -->
<para>

</para>

@g_class: 
@Returns: 


<!-- ##### FUNCTION g_type_interface_peek ##### -->
<para>

</para>

@instance_class: 
@iface_type: 
@Returns: 


<!-- ##### FUNCTION g_type_children ##### -->
<para>
Return a newly allocated and 0 terminated array of type IDs, listing the
child types of @type. The return value has to be g_free()ed after use.
</para>

@type:       The parent type.
@n_children: Optional #guint pointer to contain the number of child types.
@Returns:    Newly allocated and 0 terminated array of child types.


<!-- ##### FUNCTION g_type_interfaces ##### -->
<para>
Return a newly allocated and 0 terminated array of type IDs, listing the
interface types that @type conforms to. The return value has to be
g_free()ed after use.
</para>

@type:         The type to list interface types for.
@n_interfaces: Optional #guint pointer to contain the number of interface types.
@Returns:      Newly allocated and 0 terminated array of interface types.


<!-- ##### FUNCTION g_type_set_qdata ##### -->
<para>

</para>

@type: 
@quark: 
@data: 


<!-- ##### FUNCTION g_type_get_qdata ##### -->
<para>

</para>

@type: 
@quark: 
@Returns: 


<!-- ##### USER_FUNCTION GBaseInitFunc ##### -->
<para>

</para>

@g_class: 


<!-- ##### USER_FUNCTION GBaseFinalizeFunc ##### -->
<para>

</para>

@g_class: 


<!-- ##### USER_FUNCTION GClassInitFunc ##### -->
<para>

</para>

@g_class: 
@class_data: 


<!-- ##### USER_FUNCTION GClassFinalizeFunc ##### -->
<para>

</para>

@g_class: 
@class_data: 


<!-- ##### USER_FUNCTION GInstanceInitFunc ##### -->
<para>

</para>

@instance: 
@g_class: 


<!-- ##### USER_FUNCTION GInterfaceInitFunc ##### -->
<para>

</para>

@g_iface: 
@iface_data: 


<!-- ##### USER_FUNCTION GInterfaceFinalizeFunc ##### -->
<para>

</para>

@g_iface: 
@iface_data: 


<!-- ##### USER_FUNCTION GTypeClassCacheFunc ##### -->
<para>

</para>

@cache_data: 
@g_class: 
@Returns: 


<!-- ##### ENUM GTypeFlags ##### -->
<para>

</para>

@G_TYPE_FLAG_ABSTRACT: 

<!-- ##### ENUM GTypeFundamentalFlags ##### -->
<para>

</para>

@G_TYPE_FLAG_CLASSED: 
@G_TYPE_FLAG_INSTANTIATABLE: 
@G_TYPE_FLAG_DERIVABLE: 
@G_TYPE_FLAG_DEEP_DERIVABLE: 

<!-- ##### FUNCTION g_type_register_static ##### -->
<para>

</para>

@parent_type: 
@type_name: 
@info: 
@flags: 
@Returns: 


<!-- ##### FUNCTION g_type_register_dynamic ##### -->
<para>

</para>

@parent_type: 
@type_name: 
@plugin: 
@flags: 
@Returns: 


<!-- ##### FUNCTION g_type_register_fundamental ##### -->
<para>

</para>

@type_id: 
@type_name: 
@info: 
@finfo: 
@flags: 
@Returns: 


<!-- ##### FUNCTION g_type_add_interface_static ##### -->
<para>

</para>

@instance_type: 
@interface_type: 
@info: 


<!-- ##### FUNCTION g_type_add_interface_dynamic ##### -->
<para>

</para>

@instance_type: 
@interface_type: 
@plugin: 


<!-- ##### FUNCTION g_type_get_plugin ##### -->
<para>

</para>

@type: 
@Returns: 


<!-- ##### FUNCTION g_type_interface_get_plugin ##### -->
<para>

</para>

@instance_type: 
@implementation_type: 
@Returns: 


<!-- ##### FUNCTION g_type_fundamental_last ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION g_type_check_flags ##### -->
<para>

</para>

@type: 
@flags: 
@Returns: 


<!-- ##### FUNCTION g_type_create_instance ##### -->
<para>

</para>

@type: 
@Returns: 


<!-- ##### FUNCTION g_type_free_instance ##### -->
<para>

</para>

@instance: 


<!-- ##### FUNCTION g_type_add_class_cache_func ##### -->
<para>

</para>

@cache_data: 
@cache_func: 


<!-- ##### FUNCTION g_type_remove_class_cache_func ##### -->
<para>

</para>

@cache_data: 
@cache_func: 


<!-- ##### FUNCTION g_type_class_unref_uncached ##### -->
<para>

</para>

@g_class: 


<!-- ##### FUNCTION g_type_check_instance ##### -->
<para>

</para>

@instance: 
@Returns: 


<!-- ##### FUNCTION g_type_check_instance_cast ##### -->
<para>

</para>

@instance: 
@iface_type: 
@Returns: 


<!-- ##### FUNCTION g_type_instance_is_a ##### -->
<para>

</para>

@instance: 
@iface_type: 
@Returns: 


<!-- ##### FUNCTION g_type_check_class_cast ##### -->
<para>

</para>

@g_class: 
@is_a_type: 
@Returns: 


<!-- ##### FUNCTION g_type_class_is_a ##### -->
<para>

</para>

@g_class: 
@is_a_type: 
@Returns: 


<!-- ##### FUNCTION g_type_check_value ##### -->
<para>

</para>

@value: 
@Returns: 


<!-- ##### FUNCTION g_type_value_is_a ##### -->
<para>

</para>

@value: 
@type: 
@Returns: 


<!-- ##### FUNCTION g_type_value_table_peek ##### -->
<para>

</para>

@type: 
@Returns: 


